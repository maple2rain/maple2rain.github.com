title: 内联
date: 2016-11-12 15:35:24
updated: 2017-02-21 16:00:46
categories:
- Study
- Computer
- PL
- C++
- Function
---
# 1 内联函数

内联函数是`真正的函数`，唯一的不同之处是内联函数在适当的地方像宏一样展开，所以不需要函数调用的开销。因此，应该尽量不使用宏，只使用内联函数。
任何在类中定义的函数自动地称为内联函数，但也可以在非类的函数前面加上`inline`关键字使之成为内联函数。但为了使之有效，`必须使函数体和声明结合在一起`，否则，编译器将他作为普通函数对待，如下：

```c++
inline int foo(); //仅声明，不一定在稍后能够得到一个内联定义
inline int foo() {} // 内联定义
```

此后，编译器将检查函数参数列表使用是否正确，并进行必要的转换，而这些事是预处理器无法完成的。

- 一般应该把内联定义放在头文件里，但是不会出现多个定义错误的情况
- 当编译器看到这个定义时，他把函数类型和函数体放到符号表里(普通函数仅存放函数类型等信息但不包括函数体)
- 当使用函数时，编译器检查以确保调用是否正确且返回值被正确使用，然后将函数调用替换为函数体，因而消除了开销
- 在类声明结束后，内联函数才会被计算，即可以在一个内联函数里使用一个较后声明的函数；但此时要注意递归调用，避免两个内联函数互相调用

内联的确占用空间，但假如函数较小，这实际上比为了一个普通函数调用而产生的代码占用的空间要少。

## 1.1 访问函数

在类中内联函数的最重要使用之一是用作`访问函数(access function)`——这是一个容许读或修改对象状态的小函数。

- 访问器和修改器

    访问函数的概念可以进一步分成`访问器(accessor)`和`修改器(mutator)`。
    
    - 访问器用于从一个对象读取状态信息
    - 修改器用于修改状态信息
    
    可以通过重载为访问器和修改器提供相同的函数名，并通过调用方式决定是读还是修改状态信息；又或者为了避免成员函数名与数据成员名相同，可以使用`get`和`set`来标识访问器和修改器。如下：
    
```c++
class Circle{
    double r; //radius
public:
    Circle(double radius = 0.0) : r(radius) {} //constructor
    double radius() const { return r; } //read
    void radius(double radius) { r = radius; } //write
    
    /* work out the same as above */
    double getRadius() const { return r; } //get
    void setRadius() { r = radius; } //set
};
```

# 2 使用预处理宏的情况

## 2.1 字符串定义

字符串定义的完成是使用`#`指示，他容许取一个标识符并把他转化为字符数组。如：

```c++
#define DEBUG(x) cout << #x << endl;//将x转化为字符串并输出
```

在使用该语句时，如`x`为标识符`aNum`时，执行将会输出`aNum`。这通常与字符串拼接一起使用。字符串拼接是指当两个相邻的字符串没有分隔符时自动拼接两个字符串。如：

```c++
cout << "hello" " world" << endl;//输出"hello world"
```

上述两个特征特别有用，他们可以共同使用以辅助调试，如:

```c++
#define DEBUG(x) cout << #x " = " << x << endl//输出变量标识符及其值
```

也可以输出跟踪信息，在此信息里打印出他们执行的语句，如：

```c++
#define TRACE(s) cerr << #s << endl, s
```

其中，`#s`将输出语句，而后一个`s`将执行语句。使用逗号分隔的原因是避免在条件或循环语句中只执行第一个语句并可能出错的情况。

## 2.2 标志粘贴

标识粘贴直接用`##`实现，他允许设两个标识符并把他们粘贴在一起自动产生一个新的标识符，如：

```c++
#define FIELD(a) char * a##_string; int a##_size //分别连接标识符a和_string及标识符a和_size
```



