title: Guide to Unix & Linux学习笔记——13.使用shell
date: 2017-05-19 11:21:23
updated: 2017-05-20 15:09:09
categories:
- Study
- Computer
- OS
- Linux
- Guide to Unix & Linux 
---
> shell的知识点繁芜杂多，内容难以一时掌握，因此，本篇笔记主要记录较为有趣且实用的操作。

# 历史列表

在输入命令时，shell会将命令保存到所谓的`历史列表`中。您可以采用不同方式访问历史列表，调取前面的命令，然后再对命令进行修改，并重新输入命令。
譬如当键入方向键上和下(或者`^P`和`^N`)，实际上是在历史列表中向后和向前移动。
但是，上述描述只允许每次查看一条命令，还有一个功能更强大的特性，他允许显示全部或者部分历史列表，然后您可以选择一条特定的命令并执行之。这种方法取决于使用的shell。通常，**Bash shell**可以使用`fc`、`history`和`!`命令。
在历史列表中，每条命令称为一个**事件**，而每个事件都有一个内部编号，称为**事件编号**。在历史列表的功能就是他可以基于事件编号调取命令。例如，可以告诉shell调取命令#24。注意，输入的每条命令都会被添加到历史列表中，包括有错误的命令，以及`history`和`fc`本身。

----------

## fc

为了显示历史列表，可以使用`-l`选项，如下：

```sh
$ fc -l
```

如果直接键入`fc`命令，则会显示默认的文本编辑器(如vi)，而文本编辑器的内容则为最近输入的一条命令，可以对其进行编辑。当退出编辑器后，shell将会执行改命令。
此外，如果希望通过事件编号调取特定的命令，则可以使用`-s`(substitute)选项，后面跟事件编号。例如，假设希望重新执行编号为#24的命令，可以使用：

```
$ fc -s 24
```

还有一种特殊情况，即希望重复输入之前输入的最后一条命令，则可以不必使用事件编号，即可重新执行上一条命令，如：

```sh
$ fc -s
```

此外，如果指定一个或多个字符，那么shell将重新执行以这些字符开头的最近一条命令，例如，为了执行以`da`开头的最近一条命令(如date)，那么可以使用：

```sh
$ fc -s da
```

如果想要对之前的命令进行修改，也同样可以使用`fc`命令，语法如下：

**fc -s** *pattern* **=** *replacement number*
*pattern*和*replacement*表示的是字符串，而*number*指的是事件编号。
例如，事件编号#24的命令是一条启动`vi`编辑器并打开一个叫**file1**文件的命令:

```sh
24  vi file1
```

假设希望再次运行这条命令，但是这次希望打开的是一个叫**file2**的文件，那么可以使用如下命令：

```sh
$ fc -s file1=file2 24
```
再次说明，如果希望使用最近使用过的命令，那么命令就比较简单。例如，假设您希望运行`date`命令，但是不小心输成了`datq`，这样将显示一个错误信息：

```sh
$ datq
bash: datq: command not found...
```
因此您希望将**q**改成**e**，然后再重新该命令，那么可以不指定事件编号，默认使用上一条命令，并键入：

```sh
$ fc -s q=e
```

当然，也可以直接使用`fc`命令直接进入编辑模式，或者使用神器[TheFuck](https://github.com/nvbn/thefuck)，相信我你会爱不释手粗口连篇🙂.

特别的，在你使用删除文件时，很可能因为键入错误而后悔不已，因为使用`rm`命令进行文件删除时，文件就再也不存在了，也没有办法来恢复文件(实际上是可以的，参考[rm误删文件恢复](http://nphard.me/2015/09/30/linux-ubuntu-rm-hui-fu/),[linux下恢复被rm的文件](http://www.gfzj.us/tech/2015/03/07/linux-file-recovery.html))。
假设你希望删除一组名为**temp、temp_backup**的文件，你希望使用下列命令：

```sh
$ rm temp*
```
但是，还有一个重要文件**temp_important**，如果使用上述命令，无疑该文件也会被删除，因此更好的策略是先按照`rm`命令准备使用的模式来使用`ls`：

```sh
$ ls temp*
```
该命令将列举所有匹配这一模式的文件，如果该列表包含已经忘记的文件，例如**temp_important**，那么就不要按照计划使用`rm`命令了。但是，如果文件列表正好符合期望，那么可以继续前进，通过将`ls`替换为`rm`并重新执行该命令删除文件，如下：

```sh
$ fc -s ls=rm
```

您也许会问，为什么要重用上一条命令呢？一旦确认这个模式匹配希望删除的文件，为什么不使用相同的模式简单地键入`rm`命令呢？
当然可以这样。但是，重用`ls`可以确保准确地获得期望的内容。如果重新键入模式，那么不管多么小心，都有可能产生错误键入，最终删错文件。另外，在许多情况下，修改上一条命令要比重新键入一条命令快。

----------

> 名称含义
**fc**
名称**fc**代表*fix command*，即修复命令。这是因为，当命令键入错误时，可以使用**fc**修改命令，然后再重新执行命令。


----------


## history

无独有偶，对于`history`命令，只需键入命令，就可以显示历史列表，但可能历史列表会很长，以至于滚动出了屏幕边界，可以使用`less`命令：

```sh
$ history | less
```

为了通过事件编号调取并执行特定命令，可以使用**!**(bang)字符，后面跟事件编号即可。注意**!**之后不能有空格，如执行编号为#24的命令：

```sh
$ !24
```

特别的，如果想执行最后执行的vi命令，则可以使用`!vi`，其将会调用最近使用的`vi`命令，打开最近使用的文件。

为了重复输入之前输入的最后一条命令，可以使用连续两个**!**，如下：

```sh
$ !!
```

而为了在重新执行命令之前对命令进行修改，语法如下(最后的**/**可无)：

**!** *number* **:s** /*pattern*/ *replacement*/

*pattern*和*replacement*表示的是字符串，而*number*指的是事件编号。
例如，事件编号#24的命令是一条启动`vi`编辑器并打开一个叫**file1**文件的命令(命令中无空格):

```sh
$ !24:/file1/file2/
```

再次说明，如果希望使用最近使用过的命令，那么命令就比较简单。例如，假设您希望运行`date`命令，但是不小心输成了`datq`，这样将显示一个错误信息：

```sh
$ datq
bash: datq: command not found...
```
因此您希望将**q**改成**e**，然后再重新该命令，那么可以不指定事件编号，默认使用上一条命令，语法如下：

**^** *pattern* **^** *replacement*

例如：
```sh
$ ^q^e
```

注意，命令中无空格，且是将首个*pattern*替换为*replacement*。

----------

> 提示
对于Bash，还有另外一个特性，即使用`Ctrl-R`(可以认为他是重新调用键)。按下`^R`，将进入一种模式，然后Bash将重新调用包含该模式的最近一条命令，例如，调用最近的一条`ls -l`命令，可以按下`^R`键然后键入`l`即可获得`ls -l`命令。
当看到希望的命令后，就可以按`Return`或`Enter`键运行该命令，或者对命令进行修改后再运行。

----------

## 列表大小

shell将历史列表存储在一个文件中。他再注销时可以自动保存这个文件，登录时可以自动恢复这个文件。
对于Bash，可以设置**HISTSIZE**环境变量。例如，要指定历史列表存放1000条命令。可以使用：

```sh
$ export HISTSIZE=1000
```

----------

# 命令行编辑

默认情况下，shell使用的是`Emacs`模式，但是，如果希望的话，也可以修改到`vi`模式。对于Bash，设置的方法如下：

```sh
$ set -o emacs  # 修改到Emacs模式
$ set -o vi # 修改到vi模式
```

----------

# 别名

`别名`就是赋予一条命令或者一列命令的名称。可以将别名作为缩写，或者使用别名创建已有命令的变体。例如，假设您发现经常输入下述命令：

```sh
$ ls -l temp*
```

如果给这条命令赋予一个别名`lt`，那么就可以键入上述命令来简化上一条命令：

```sh
$ lt
```

对于Bash，创建别名时需要使用`alias`命令，其语法为：

**alias** [*name* **=** *commands*]
**注意：**确定等号两边不要有空格。

作为示例，上述例子创建别名的方式如下：

```sh
$ alias lt='ls -l temp*'
```

**注意：**上述例子将命令引用在**单引号**中。这是因为该命令包含有多个空格和一个元字符(*)。通常，强引用(单引号)要比弱引用(双引号)好，因为他们保留元字符的含义，直至别名执行。

同样，也可以为含有两条命令的一串命令创建别名，如下：

```sh
$ alias info='date; who'
```

一个最方便的别名，莫过于将`alias`本身创建一个别名：

```sh
$ alias a=alias
```

当然，如需修改别名的含义，则只需对其重定义即可。
为了查看别名，可以直接键入`alias`命令，将显示所有的别名。而倘若想查看某一别名的含义，如`info`，则可以使用：

```sh
$ alias info
```

为了移除别名，可以使用`unalias`命令，该命令的语法为：

**unalias** *name*
其中，*name*是别名的名称。例如，要移除刚才定义的别名，可以使用：

```sh
$ unalias info
```
如果希望同时移除所有的别名，可以添加`-a`选项。

必须知道的是，别名在终端设置后只在当前会话有效，为了方便起见，可以将别名定义放在在`.bashrc`文件中。

----------

## 临时挂起命令

别名的一个非常常见的应用就是让用户在每次运行特定命令时，能够方便地使用相同的选项。
例如，`ls`命令经常被设置别名为`ls --color=auto`，此时显示的目录内容将是被高亮的。倘若想运行原始命令，而不是别名，则可以将其临时挂起，方法为在命令开头键入一个\ (反斜线)：

```sh
$ \ls
```

----------

## 避免删错文件

在上文中，曾说到使用`fc -s ls=rm`来避免删错文件，但这条命令未免有点过长，偷懒的您，想必已经想到使用下述方法来解决问题了：

```sh
$ alias del='fc -s ls=rm'
```

----------

## 怎么方便怎么来

还记得使用`fc -s`后接字符串以执行以该字符串开头的命令吗，干脆直接将`fc -s`命令别名为`r`(redo之意)，那么，要重新执行`date`命令，只需键入：

```sh
$ r d
```
多么方便呐🙂。

----------

# Reference

[1] Haeley Hahn. Unix & Linux 大学教程[M]. 张杰良, 译. 北京:清华大学出版社, 2010.1:268-287.