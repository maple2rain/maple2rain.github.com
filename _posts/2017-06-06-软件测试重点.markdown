---
layout: post
author: LPF
title: 软件测试重点
date: 2017-06-06 10:31:01
updated: 2017-06-06 21:29:42
categories:
- School
---
# 考纲

六道大题。

## 概念题

1. 软件测试各阶段
2. 白盒测试、黑盒测试优缺点、概念、方法
3. 集成测试概念及方法

## 实践题

1. 代码审查
2. 白盒测试——逻辑覆盖：流程图、方法、用例
3. 独立路径：控制流图、环形复杂度
4. 黑盒测试的各种方法
5. 集成测试过程
6. 场景法设计测试用例

# 复习重点

## 软件测试阶段

测试过程分单元测试、集成测试、系统测试及验收测试。
测试流程：

1. 制定测试计划
    一般来说，制定测试计划的目的是用来识别任务，分析风险，规划资源和确定进度。
2. 设计测试方案
    测试的设计阶段要设计测试用例和测试过程，要保证测试用例完全覆盖测试需求。
3. 测试准备和测试环境的建立
    准备阶段要完成测试前的各项准备工作，主要包括全面准确掌握各种测试资料，熟悉测试平台等。
4. 执行测试
    执行测试是执行所有的或一些选定的测试用例，并观察其测试结果，可以分为以下几个阶段：
    单元测试、集成测试、系统测试、验收测试，每个阶段都包含回归测试。
5. 测试评估
    测试评估的的主要方法包括缺陷评估、覆盖评测和质量评测。
6. 测试总结
    测试工作的每个阶段都应该有相应的测试总结。

## 白盒测试

概念：
已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否已经过检查。
白盒测试的测试对象基本上是源程序，是以程序的内部逻辑为基础的一种测试方法。

### 语句覆盖

语句覆盖使程序重每个语句至少都能被执行一次。

### 判定覆盖

每个判断的取真分支和取假分支至少经历一次，即判断的真假值均曾被满足。

### 条件覆盖

构造一组测试用例，使得每一判定语句中每个逻辑条件的可能值至少满足一次。

### 条件判定组合覆盖

设计足够的测试用例，使得判定中每个条件的所有可能至少出现一次，并且每个判定的判定结果也至少出现一次。

### 多条件覆盖

设计足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。

### 路径覆盖

路径覆盖的目的就是要使设计的测试用例能覆盖被测试程序中所有的可能路径。

### 例题

![](../post_img/5937694dab64414eac000643)

对于第一个判定( (x>3)&&(z<10) )：
	
- 条件x>3    取真值记为T1，取假值记为-T1
- 条件z<10  取真值记为T2，取假值记为-T2

对于第二个判定( (x==4)||(y>5) )：

- 条件x==4  取真值记为T3，取假值记为-T3 
- 条件y>5    取真值记为T4，取假值记为-T4

满足各种逻辑覆盖：

- 条件覆盖
![](../post_img/5937694dab64414eac000644)
- 多条件覆盖
|条件|记号|分支|
|---|
|x>3, z<10|T1 T2|第一个判定的取真分支|
|x>3, z>=10|T1 -T2|第一个判定的取假分支|
|x<=3, z<10|-T1 T2|第一个判定的取假分支|
|x<=3, z>=10|-T1 -T2|第一个判定的取假分支|
|x==4, y>5|T3 T4|第二个判定的取真分支|
|x==4, y<=5|T3 -T4|第二个判定的取真分支|
|x!=4, y>5|-T3 T4|第二个判定的取真分支|
|x!=4, y<=5|-T3 -T4|第二个判定的取假分支|

![](../post_img/5937694dab64414eac000647)

- 路径覆盖

![](../post_img/5937694dab64414eac000642)

### 控制流图

![](../post_img/5937694dab64414eac000648)

### 环形复杂度

给定控制流图G的环形复杂度V(G)，定义为
$$V(G) = E-N+2$$
其中，E是控制流图中边的数量，N是控制流图中的节点数量。
也可定义为
$$V(G) = P+1$$
其中，P是控制流图G中判定节点的数量。

### 基本路径测试法的步骤

```c
void  Sort ( int  iRecordNum, int iType )
1 {  
2    int  x=0;
3    int  y=0;
4    while ( iRecordNum--> 0 )
5    {
6         if ( iType==0 )
7	     { x=y+2; break; }
8         else
9	     if ( iType==1 )
10                    x=y+10;
11             else
12                    x=y+20;
13    }
14 }
```

1. 画出程序控制流图
![](../post_img/5937694dab64414eac000646)
2. 计算程序环路复杂性
10（边）- 8（节点）+ 2 = 4
3. 确定独立路径组合
- 路径1：4→14
- 路径2：4→6→7→14
- 路径3：4→6→9→10→13→4→14
- 路径4：4→6→9→12→13→4→14
4. 准备测试用例
![](../post_img/5937694dab64414eac000641)

## 黑盒测试

概念：已知产品的功能设计规格和用户手册，可以进行测试证明每个功能是否实现、每个实现了的功能是否符合要求，以及产品的性能是否满足用户的要求。

黑盒测试也称数据驱动测试，在测试时，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试。
在黑盒测试过程中，只是通过**输入数据、进行操作、观察输出结果**，来检查软件系统是否按照需求规格说明书的规定正常使用，软件是否能适当地接收输入数据而产生正确的输出信息，并保持外部信息的完整性。

### 等价类划分法

等价类划分法是把所有可能的输入数据，即程序的**输入域**划分为若干部分（子集），然后从每一个子集中**选取少数具有代表性**的数据作为测试用例。

- 例题

1. 步骤：条件分析
    - 3条边分别为A、B、C，满足：A>0，B>0，C>0，且A+B>C，B+C>A，A+C>B；
    - 等腰需满足A=B，或B=C，或A=C ；
    - 等边需满足A=B，且B=C，且A=C ；
2. 列出等价类列表
![](../post_img/5937694dab64414eac000640)
3. 设计测试用例
![](../post_img/5937694dab64414eac000645)

### 边界值分析法

边界值分析法就是**对输入或输出的边界值**进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。

1. 首先确定边界情况：通常输入或输出等价类的边界就是应该着重测试的边界情况。
2. 选取**正好等于、刚刚大于或刚刚小于边界的值**作为测试数据，而不是选取等价类中的典型值或任意值。

例：有二元函数f(x,y)，其中x∈[1,12]，y∈[1,31]。                     则采用边界值分析法设计的测试用例是：
   { <1,15>, <2,15>, <11,15>, <12,15>, <6,15>, <6,1>, <6,2>, <6,30>, <6,31> }
推论：对于一个含有n个变量的程序，采用边界值分析法测试程序会产生4n+1个测试用例。
练习：有函数f(x,y,x)，其中x∈[1900,2100]，y∈[1,12]，z∈[1,31]的。请写出该函数采用边界值分析法设计的测试用例。
  { <2000,6,1>, <2000,6,2>, <2000,6,30>, <2000,6,31>, <2000,1,15>, <2000,2,15>, <2000,11,15>, <2000,12,15>, <1900,6,15>, <1901,6,15>, <2099,6,15>, <2100,6,15>, <2000,6,15> }

健壮性测试，则还需要增加一个略大于最大值和略小于最小值的取值。


## 黑盒白盒测试对比

|测试方法|黑盒测试|白盒测试|
|---|
|测试依据|规格说明|程序内部结构|
|优点|能确保从用户的角度出发进行测试|能对程序内部的特定部位进行覆盖测试|
|缺点|无法测试程序内部特定部位；<br>当规格说明有误，则不能发现问题|无法检查程序的外部特性；<br>无法对未实现规格说明的程序内部欠缺部分进行测试|
|应用范围|边界分析法<br>等价类划分法<br>决策表测试<br>场景法|语句覆盖，判定覆盖<br>条件覆盖，判定/条件覆盖<br>路径覆盖，循环覆盖<br>模块接口测试|

## 集成测试

将经过单元测试的模块按设计要求连接起来，组成所规定的软件系统的过程称为**集成**。
集成测试是组装软件的系统测试技术之一，按设计要求把通过单元测试的各个模块组装在一起之后，进行集成测试的主要任务是要求软件系统符合实际软件结构，发现与接口有关的各种错误。
① 将各模块连接起来，检查模块相互调用时，数据经过接口是否丢失。
② 将各个子功能组合起来，检查能否达到预期要求的各项功能。
③ 一个模块的功能是否会对另一个模块的功能产生不利的影响。
④ 全局数据结构是否有问题，会不会被异常修改。
⑤ 单个模块的误差积累起来，是否被放大，从而达到不可接受的程度。

### 集成测试方法

- 非增量式测试方法
概括来说，非增量式测试方法是采用一步到位的方法来进行测试，即对所有模块进行个别的单元测试后，按程序结构图将各模块连接起来，把连接后的程序当做一个整体进行测试。
- 增量式测试方法
    - 自顶向下增量式测试
    自顶向下增量式测试表示逐步集成和逐步测试是按结构图自上而下进行的。即模块集成的顺序是首先集成主控模块（主程序），然后按照软件控制层次结构向下进行集成。
    - 自底向上增量式测试
    自底向上增量式测试是从最底层的模块开始，按结构图自下而上逐步进行集成和测试。