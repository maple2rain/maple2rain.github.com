---
layout: post
author: LPF
title: 自己管理常量
date: 2016-10-30 13:24:30
updated: 2017-02-21 16:19:03
tags:
- PL
categories:
- Study
- Computer
- PL
---
## 1 访问内存代价大

大部分现代CPU不支持对浮点常量的立即寻址模式，从而在程序中使用这些常量时就相当于访问以此常量初始化的变量。
该“变量”就会放置于内存中，倘若该内存单元不在数据缓存中，那么引用它时就需要访问内存，从而降低程序运行速度。

## 2 立即寻址模式的遗憾

在32位处理器上，**CPU**经常用整数寄存器和立即寻址模式进行简单的32位浮点数操作，从而避免了访问内存的代价——倘若数据未在缓存中。
但这个技巧对双精度浮点变量赋值不管用，如**GCC**仍是会从内存保留该常量的拷贝，当要想某浮点变量赋以此常量值时，就从内存单元中将值拷贝过来。

优化型的编译器会在内存中创建并维护一个常量表，若源文件中多次引用某常量，则编译器就会只对那个常量分配一处内存位置。
但这种优化仅对单个源文件成立，若不同文件都引用同一个常量值，编译器可能为此常量创建多个拷贝。
存在数据的多个拷贝显然是浪费存储资源，但更大的麻烦是程序通常以随机方式访问这些常量，故而后者很少待在缓存中，并且这些常量值很有可能将原本更频繁使用的数据挤出缓存。

## 3 自己管理常量

对上述问题的一个解决方法就是自己管理浮点常量。
由于这些常量从程序角度看更像是变量，所以可以用浮点常量对静态变量初始化让其“作为常量”。

- 示例
    
    ```c
    #include <stdio.h>
    static double OnePointZero = 1.0;

    int main(void)
    {
        static double i;
        i = OnePointZero;
        return 0;
    }
    ```

上述例子将浮点常量看成是静态变量显然毫无益处。
但在更复杂的场合，存在着若干浮点常量时，就可以分析程序，找出哪些常量时访问频繁的，从而把所对应的变量放入相邻内存单元。
因为大多数**CPU**处理引用时都有局部性特征，即还会访问邻近的变量，所以在访问这些常量数据中的某一个时，缓存线也会填充以邻近数据。
因而，倘若在短时间内又要访问其他变量数据时，后者很可能就在缓存中了。
另外，**自行管理常量**能创建完整的常量集，供不同的编译单位(即源文件)来引用，所以程序只用对某常量设立设立一个内存位置，而不必在内存中有多个拷贝。