---
layout: post
title:  "从数字转换为字符串引发的一些问题"
date:   2015-02-10 15:14:54
categories: jekyll
tags: jekyll
excerpt: 从数字转换为字符串引发的一些问题。
mathjax: true
---

[TOC]

## 1 数字如何转换为字符串
一般而言，若想将数字转换为字符串，可以将该数字的每个数字依次转换为字符型。使用不断求余再依次将数字右移直到数字为0时结束的方法即可。但这种方法有一个小缺点，那就是当出现负数时，需要多加一次判断和转换操作，因而可能会有点效率问题，那如何解决这个问题呢？

## 2 正负数通用转换为字符串的方法
基于想要找出有效的转换算法，**Matthew Wilson**提出了一种巧妙地算法，那就是用一个对称的digits数组解决负数转换的边界条件问题，代码大致如下：
```cpp
const char* convert(char buf[], int value)  
{  
    static char digits[19] =  {
             '9', '8', '7', '6', '5', '4', '3', '2', '1',  
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };  
    static const char* zero = digits + 9;  // zero 此时指向 '0'  
    // works for -2147483648 .. 2147483647  
    int i = value;  
    char* p = buf;  //buf初始时为空

    do {  
        int lsd = i % 10;   // lsd 可能小于 0  
        i /= 10;            // 是向下取整还是向零取整？  
        *p++ = zero[lsd];   // 下标可能为负，即从zero往回走|lsd|个单位    
     } while (i != 0);  

    if (value < 0) {  
        *p++ = '-';  
    }  

    *p = '\0';  
    std::reverse(buf, p); //进行翻转 
    return p; // p - buf 即为整数长度  
}  
```

程序中，数字的每一位都被依次转换为字符并添加到buf数组中，最后将其逆置就是需要的字符串了。
然而，与之而来的就是另一个问题，对负数求余的结果会是什么？

## 3 负数求余法则
### 3.1 自然数的曲模运算的定义
    如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数 q 和 r，满足 a = qd + r 且0 ≤ r < d。其中，q 被称为商，r 被称为余数。

在这个定义中，很明显可以可以看到，取余求得的模r总是非负数，而商则决定于被除数和除数。
但是这个规则仅能用于正数，而无法运用在负数上，因此可以对这个法则进行扩充，有：

    如果a 与d 是整数，d 非零，那么余数 r 满足这样的关系：a = qd + r , q 为整数，且0 ≤ |r| < |d|。

### 3.2 被除数为负数、除数为正数
举个例子，如对(-7) mod 3,则有以下的可能结果

    (-7) % 3 = 2 ==> -7 = (-3) * 3 + 2

然而，尽管有如此规定，不同语言对其还是有不同解释。就以上例子来说，其也可以定义为

    (-7) % 3 = -1 ==> -7 = (-3) * (-2) + (-1)

因此，在此时的模为(-1)或2都应该是正确的结果，此时称这种情况为该**被除数求余后有正余数和负余数**；而在不同语言中，则要看其标准和编译器实现为如何了。比如有如下实现
   
    C++（G++ 编译）： cout << (-7) % 3; // 输出 -1
    Java（1.6）： System.out.println((-7) % 3); // 输出 -1
    Python 2.6：>>>  (-7) % 3 // 输出 2
    百度计算器：(-7) mod 3 = 2
    Google 计算器：(-7) mod 3 = 2
 
### 3.3 被除数为正数，除数为负数
对于除数为负数的情况，还是要举一个例子，如对7 mod (-3)，则有以下结果

    7 % (-3) = -2 ==> 7 = (-3) * (-3) - 2

又或者是

    7 % (-3) = 1 ==> 7 = (-3) * (-2) + 1

此时又有正余数和负余数的情况，而具体结果则要看语言标准与编译器实现了，如以下实现

    C++（G++ 编译）： cout << 7 % (-3); // 输出 1
    Java（1.6）： System.out.println(7 % (-3)); // 输出 1
    Python 2.6：>>>  输出 -2
    百度计算器：7 mod (-3) = -2
    Google 计算器： 7 mod (-3) = -2

## 4 各语言标准
- 对于基于C语言的语言，在C99及之后，已经明确规定了商是向0取整的，也就意味着余数的符号与被除数相同。
- 对于Python、Ruby等语言，则在语言参考手册中表明，商是向负无穷取整的，即在负数的情况下，商可能会偏小。
- 但具体情况还是要参照语言参考规定。
