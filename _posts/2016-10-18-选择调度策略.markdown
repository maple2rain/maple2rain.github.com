---
layout: post
title: 选择调度策略
date: 2016-10-18 22:36:46
updated: 2017-02-21 15:07:09
tags:
- OS
categories:
- Study
- Computer
- OS
---
# 1 选择函数
**选择函数(selection function)**确定在就绪进程中选择哪一个进程在下一次执行。
该函数可以基于优先级、资源需求或者该进程的执行特性。对于最后一种情况，下面的三个量是非常重要的：

- w : 花费的等待时间
- e : 到现在为止，花费的执行时间
- s : 进程所需要的总服务时间，包括e；通常，该数量必须由用户估计或提供

## 1.1 各种调度策略的特点

|策略|选择函数|决策模式|吞吐量|相应时间|开销|对进程的影响|饿死|
|---|---|
|FCFS|max[w]|非抢占|不强调|可能很高，特别是<br>当进程的执行时间<br>差别很大时|最小|对短进程不利；<br>对受I/O限制的进程不利|
|轮转|常数|抢占(时间片)|如果时间长<br>吞吐量低|为短进程提供好的<br>响应时间|最小|公平对待|无|
|SPN|min[s]|非抢占|高|为短进程提供好的<br>响应时间|可能比较高|对长进程不利|可能|
|SRT|min[s-e]|抢占(在到达时)|高|提供好的响应时间|可能比较高|对长进程不利|可能|
|HRRN|max($\frac{w + s}{s})$|非抢占|高|提供好的响应时间|可能比较高|很好的平衡|无|
|反馈|(参见正文)|抢占(在时间片<br>用完时)|不强调|不强调|可能比较高|可能对受I/O限制<br>的进程有利|可能|

## 1.2 决策模式

**决策模式(decision mode)**说明选择函数在被执行的瞬间的处理方式，通常可分为以下两类：

- 非抢占：在这种情况下，一旦进程处于运行态，他就不断运行直到终止，或者为等待I/O或请求某些操作系统服务而阻塞自己
- 抢占：当前正在运行的进程可能被操作系统中断，并转移到就绪态。关于抢占的决策可能是在一个新进程到达时，或者一个中断发生后把一个被阻塞的进程置为就绪态时，或者基于周期性的时间中断。

# 2 调度策略

## 2.1 先来先服务

最简单的策略是先来先服务(FCFS，First-Come-First-Served)，也称为先进先出或严格排队方案。当每个进程就绪后，他就加入就绪队列。当当前正在运行的进程停止执行时，选择在就绪队列中存在时间最长的进程运行。
**FCFS**执行长进程比执行短进程更好。

- 偏向受处理器限制的进程
    考虑有一组，其中有一个进程大多数时候都使用处理器(受处理器限制)，还有许多进程大多数时候进行I/O操作(受I/O限制)。
    如果一个受处理器限制的进程正在运行，则所以受I/O限制的进程都必须等待。有一些进程可能在I/O队列中，但是当受处理器限制的进程正在执行时，他们可能移回就绪队列。这时，大多数或所有I/O设备都可能是空闲的，即使可能他们还有工作要做。
    在当前正在运行的进程离开运行态时，就绪的受I/O限制的进程迅速地通过运行态，又阻塞在I/O事件上。
    如果受处理器限制的进程也被阻塞了，则处理器空闲，因此，FCFS可能导致 处理器和I/O设备都没有得到充分利用。

- 与优先级策略结合
    FCFS自身对于单处理器系统并不是很有吸引力的选择。但是，他通常与优先级策略相结合，以提供一种更有效的调度方法。
    因此，调度器可以维护许多队列，每一个优先级一个队列，每个队列中的调度基于FCFS。

## 2.2 轮转

轮转法(Round Robin)即是以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列中，然后基于FCFS策略选择下一个就绪作业运行。
这种技术也被称为**时间片(time slicing)。因此，每个进程在被抢占前都给定一片时间。

- 时间片长度
    对于轮转法，基于设计的问题是使用的时间片的长度。
    - 如果时间非常短，则短作业会相对比较快地移动通过系统
    - 另一方面，处理时钟中断、执行调度和分派函数都需要处理器开销
    
    一个有用的指导思想是时间片最好略大于一次典型的交付所需要的时间。
    - 如果小于这个时间，则大多数进程都至少会需要两个时片
    - 而当一个时间片比运行时间最长的进程还要长时，则轮转法退化为FCFS

- 偏向受处理器限制的进程
    轮转法在通用的分时系统或事务处理系统中都特别有效，然而他偏向于受处理器限制的进程。通常，受I/O限制的进程要比受处理器限制的进程使用处理器(花费在I/O操作之间的执行时间)的时间短。
    如果既有受处理器限制的进程又有受I/O限制的进程，就有可能发生如下情况：
    - 一个受I/O限制的进程只使用处理器很短的一段时间，然后因为I/O而被阻塞，等待I/O操作的完成，然后就加入到就绪队列
    - 另一方面，一个受处理器限制的进程在执行过程中通常使用一个完整的时间片并立即返回到就绪队列中
    
    因此，受处理器限制的进程倾向于不公平地使用了大部分处理器时间，从而导致受I/O限制的进程性能降低，使用I/O设备低效，响应时间的变化大。
- 虚轮转法(Virtual Round Robin)
    1. 新进程到达并加入就绪队列，是基于FCFS管理的
    2. 当一个正在运行进程的时间片用完后，他返回到就绪队列
    3. 当一个进程被I/O操作阻塞时，他加入到辅助队列，辅助队列比其他就绪队列的优先级更高
    4. 当一个进程从辅助队列中调度时，他的运行时间不会长于基本时间片减去他上一次从就绪队列中被选择运行的总时间

## 2.3 最短进程优先
最短进程优先(Shorted Process Next, SPN)策略是一种非抢占策略，其原则是下一次选择所需处理时间最短的进程。

- 估计所需处理时间
    SPN策略的难点在于需要知道或至少需要估计每个进程所需要的处理时间。
    - 对于批处理作业，系统高要求程序员估计该值，并提供给操作系统
        如果程序员的估计远低于实际运行的时间，系统就可能终止该作业。
    - 在生产环境中，相同的作业频繁地运行，可以收集关于他们的统计值
    - 对于交互进程，操作系统可以为每个进程保留一个运行平均值
        - 简单算法
        $$S_{n + 1} = \frac{1}{n}\sum_{i = 1}^{n}T_{i}$$ 
        其中，
            $T_{i}$：该进程的第i个实例的处理器执行时间（对批作业而言是总的执行时间；对交互作业而言指处理器一次短促的执行时间）
            $S_{i}$：第i个实例的预测值
            $S_{1}$：第1个实例的预测值，不用计算
        为避免每次重新计算总和，可以把上式重写为
        $$S_{n + 1} = \frac{1}{n}T_{n} + \frac{n - 1}{n}S_{n}$$
        - 指数平均法
        $$S_{n + 1} = \alpha T_{n} + (1 - \alpha)S_{n}$$
        其中，$\alpha$是一个常数加权因子(0 < $\alpha$ < 1)，用于确定距现在比较近或比较远的观测数据的相对权值。
        $\alpha$的值越接近1，则平均值越能够迅速反应观测值的快速变化，缺点是如果观测值出现短促波动，则平均值会出现急剧变化。

- 长进程可能被饿死
    - SPN的风险在于只要持续不断地提供短进程，则长进程可能被饿死
    - 另一方面，由于缺少抢占机制，他对分时系统过事务处理环境仍然不理想

## 2.4 最短剩余时间
最短剩余时间(Shortest Remaining Time, SRT)是针对SPN增加了抢占机制的版本。
在这种情况下，调度器总是选择预期剩余时间最短的进程。
当一个新进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此，只要新进程就绪，调度器就可能抢占当前正在运行的进程。
和SPN一样，调度器在执行选择函数时必须有关于处理时间的估计，并且存在长进程被饿死的危险。

- 结论
    - SRT不像FCFS偏向长进程，也不像轮转会产生额外的中断，从而减少了开销
    - SRT必须记录过去的服务时间，增加了开销
    - SRT比SPN的周转时间短，从而有更好的性能，因为相对于一个正在运行的长作业，短作业可以立即被运行

## 2.5 最高响应比优先
周转时间即是进程所需服务时间加上等待时间。
而响应比即是周转时间与实际服务时间的比率。
对于每个单独的进程，我们都希望该值最小，并且希望所有进程的平均值也最小。
我们事先并不知道服务时间是多少，但可以基于过去的历史或用户和配置管理员的某些输入值近似地估计他。
    
考虑下面的比值：
    $$R = \frac{w + s}{s}$$
    
其中，
    R：响应比
    w：等待处理器的时间
    s：期待的服务时间

如果该进程被立即调度，则R等于标准的周转时间。注意，R的值最小为1.0，只有第一个进入系统的进程才能达到该值。
因此，调度规则如下：**在当前进程完成或被阻塞时，选择R值最大的就绪进程。**
当偏向短作业时，长进程由于得不到服务的时间不断地增加，从而增大了比值，最终在竞争中胜了短进程。
和SRT、SPN一样，使用最高响应比(Highest Response Ratio Next, HRRN)策略需要估计期待的服务时间。


## 2.6 反馈
如果没有关于各个进程相对长度的任何信息，则SPN、SRT和HRRN都不能使用。
另一种偏向短作业的方法是处罚运行时间较长的作业，即倘若无法把焦点放在剩余的执行时间上，那就把焦点放在已经执行的时间上。

调度基于抢占原则(时间片)并且使用动态优先级机制。

- 当第一个进程第一次进入系统时，他被放置于RQ0
- 当他第一次被抢占并返回就绪态时，他被放置于RQ1
- 在随后的时间里，每当他被抢占时，他被降级到下一个低优先级队列中
- 一个短进程很快会执行完，因而不会降很多级，而长进程会逐级下降
    - 在每个队列中，除了最低优先级队列外，都是用简单的FCFS机制
    - 在最低优先级队列中，使用轮转方式对待，被抢占进程重新回到该队列

- 方案变体
    该简单方案存在的一个问题是长进程的周转时间可能被惊人的增加。
    事实上，如果频繁地有新作业进入该系统，就有可能出现饿死的情况。
    为补偿这一点，可以：
    - 在RQi中调度的进程允许执行$2^i$的时间，然后才被抢占
    - 当进程在当前队列中等待服务的时间超过一定的时间量后，把他提升到一个优先级较高的队列中
    











