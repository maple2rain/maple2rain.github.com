---
layout: post
author: LPF
title: Linux命令之find
date: 2017-05-24 19:53:26
updated: 2017-06-24 12:04:47
tags:
- Linux Command
categories:
- Study
- Computer
- OS
- Linux
- Command
---
> 尽管`whereis`和`locate`可以较快速的查找到文件，但遗憾的是，前者只搜索与特定程序关联的文件(可执行文件、源文件、文档文件)，后者实际上不执行搜索，只简单地在数据库查找匹配的模式。当需要完全进行查找时，还是得靠工具——`find`。

# 用法

`find`程序的一般格式为

```sh
$ find path... test... action...
```
其中，*path*为目录路径，*test*为测试，*action*是处理动作。

- 目录路径：将被查找的目录树，包括其子目录
- 测试：对于遇到的每个文件，`find`应用指定的测试条件，目标即创建一个满足指定标准的所有文件的列表
- 一旦搜索完成，对列表中的每个文件执行指定的操作

考虑下述简单例子：

```sh
$ find /home/maple -name important -print
```

可以将这条路径分为下述几部分：

- 目录路径：/home/maple
- 测试：-name important
- 动作：-print

在这条命令中，对`find`指派了如下指示：

- 目录路径：从**/home/maple**开始，搜索所有的文件和子目录
- 测试：对于每个文件，应用测试`-name important`(该测试的含义为查找名为*important*的文件)
- 动作：对于每个通过测试的文件，执行动作`-print`(输出路径名)

即，上述命令的作用是在**/home/maple**目录下显示所有命名为*important*的文件的路径名。

----------

# 路径

每条`find`程序的开头可以由一个或多个路径构成，这些路径表明`find`从何处开始进行搜索。
如果不指定路径，则默认为**当前工作目录**。

----------

# 测试

为了查找满足指定标准的文件，可以指定一个或多个**测试**。
`find`程序的测试条件十分繁多，以下列出最重要的测试：

## 根据文件名

|测试|解释|
|---|
|-name *pattern*|包含*pattern*的文件名|
|-iname *pattern*|包含*pattern*的文件名(不区分大小写)|

可以使用**通配符**，但要记得引用引号。

----------


## 根据文件特征

|测试|解释|
|---|
|-type [df]|文件类型：**d**=目录，**f**=普通文件，同文件类型标识|
|-perm *mode*|设置为*mode*文件权限|
|-user *userid*|属主为*userid*|
|-group *groupid*|组为*groupid*|
|-size [-+]n[cbkMG]|大小小于或大于n[字节、块、千字节、兆字节、吉字节|
|-empty|空文件|
 
 

----------


## 根据时间

注释：**-**表示访问过，**+**表示未访问。

|测试|解释|
|---|
|-amin [-+]n|之前n分钟内访问|
|-anewer *file*|*file*文件被修改之后访问过|
|-atime [-+]n|之前n天内访问|
|-cim [-+]n|之前n分钟状态改变(访问或修改)|
|-cnewer *file*|*file*文件修改后状态改变|
|-ctime [-+]n|之前n天内状态改变|
|-mmin [-+]n|之前n分钟修改|
|-mtime [-+]n|之前n天修改|
|-newer *file*|*file*文件修改后修改|
 
 
 

----------

## 对测试求反

当需要时，可以通过在测试面前加一个**!**(感叹号)运算符对测试求反。当使用**!**时，必须遵循下述两条规则：

- 必须在**!**的两边各留一个空格，这样才能正确地解析**!**
- 必须引用**!**，才能将**!**传递给`find`，而不会被shell解释

作为实力，考虑下述命令，该命令搜索home目录，并显示所有扩展名为**.jpg**的普通文件：

```sh
$ find ~ -type f -name '*.jpg' -print
```

相反，假定我们希望显示那些扩展名不是**.jpg**的文件名，则是使用**!**对测试求反：

```sh
$ find ~ -type f \! -name '*.jpg' -print
```

注意，这里使用了一个反斜线引用**!**，您也可以使用单引号：

```sh
$ find ~ -type f '!' -name '*.jpg' -print
```

当有必要时，还可以对多个测试求反，这种情况下，只需确保每个测试都有自己的**!**即可。例如，您希望查看既不是普通文件也不是目录文件的文件，即查看符号链接、命名管道、特殊文件等，使用的命令为：

```sh
$ find ~ \! -type f \! -type d -print
```

----------

# 动作

动作告诉`find`对查找到的文件执行什么操作，最重要的动作如下表：

|动作|解释|
|---|
|-print|将路径名写入到标准输出，默认动作|
|-fprint *file*|同-print;将输出写入到*file*中|
|-ls|显示长目录列表，并不执行`ls`程序，格式化在内部完成|
|-fls *file*|同-ls;将输出写入到*file*中|
|-delete|删除文件|
|-exec *command* {} \;|执行*command*，{}指示匹配的文件名|
|-ok *command* {} \;|同-exec，但是在运行*command*之前进行确认|

对于`-delete`选项，可以说是非常有用。只不过其很容易产生不良后果，因为删除的文件难以重来。该动作移除搜索中查找到的每个文件，类似于`rm`命令。
例如，为删除home目录下至少有180天未访问过且扩展名为**.backup**的文件，可以使用如下命令进行批量删除：

```sh
$ find ~ -name '*.backup' -atime +180 -delete
```

此外，还有更具一般性的执行命令程序：使用`-exec`动作将搜索输出发送给任何希望的程序。相应的语法为：

```sh
-exec command {} \;
```

其中，*command*是您任何希望的命令，包括选项和参数。
在`-exec`命令之后键入一条命令，就像在命令行上键入命令一样。在命令内，可以使用字符**{}**表示`find`查找到的路径名。为了表达命令的末尾，必须以**;**结束命令。
`-exec`为每个文件产生一条单独的命令，如，如上述的删除文件命令，可以修改为下述命令达到相同效果，每搜索到一个文件执行一次`rm`操作：

```sh
$ find ~ -name '*.backup' -atime +180 -exec rm -f {} \;
```
对于一些shell来说，可能需要对花括号进行引用，在此可以使用反斜线或双引号。

对于`-exec`，一个有效的变体就是`-ok`，其会在命令执行前请求确认。


```sh
$ find ~ -name '*.backup' -atime +180 -ok rm -f {} \;
```

----------

# 处理查找到的文件：xargs

`xargs`可以运行任何使用参数指定的命令，参数通过标准输入传递给该程序。该程序的语法为：

```sh
$ xargs [-prt] [-istgring] [command [argument...]]
```
其中，*command*是希望运行的命令的名称，*string*是占位符，*argument*是从标准输入读取的参数。
作为一个简单的例子，假设希望查看home目录下所有普通文件的列表，并显示其长格式，可以使用`find`程序找到该文件列表，再将输出管道传送给`xargs`，而`xargs`运行`ls -l`显示文件长格式：

```sh
$ find ~ -type f | xargs ls -l
```

又比如，假设希望统计有多少个普通文件，可以通过将查找出来的文件通过`xargs`传递给`echo`，`echo`将接收到的文件名整理输出成一个包含所有文件名的长行，再由`wc`程序进行计数即可：

```sh
$ find ~ -type f | xargs echo | wc -w
```

有时候，希望在同一命令中使用参数多次传送给`xargs`，为了这样做，可以使用`-i`(insert)选项，这将允许**{}**作为占位符，占位符将在命令运行之前被参数替代，例如，将当前目录下的普通文件都拷贝到另一个目录中，并在拷贝时重命名文件：

```sh
$ find . -type f | xargs -i cp {} ~/backup/{}.bak
```

如果希望使用`-i`，但出于某些原因不想使用**{}**，那么可以自己指定占位符。只需在`-i`之后直接键入占位符即可，例如使用**XX**替代**{}**：

```sh
$ find . -type f | xargs -iXX cp XX ~/backup/XX.bak
```

倘若害怕出现问题，可以使用`-p`(prompt)选项，在运行命令之前显示提示。

最后，一个值得学习的选项是`-r`。一般情况下，`xargs`运行指定的命令至少一次。`-r`选项告诉`xargs`如果没有输入参数，则不运行命令。例如，下述命令搜索工作目录，显示空文件的长列表：

```sh
$ find . -empty | xargs ls -l
```

但是，假定当前工作目录没有空文件，那么`ls -l`没有任何参数，他将执行默认操作，即生成一个有关整个目录的长列表，而这并不是我们所希望的，因此，可以使用`-r`选项避免该问题：

```sh
$ find . -empty | xargs -r ls -l
```

实际上，`xargs`并不是只能与`find`一起协作。他可以与任意程序一起使用，只要这些程序可以向`xargs`提供作为参数使用的字例如，假设您有一个文件**filename**，该文件包含许多文件的名称，您希望使用`cat`程序将这些文件的数据全部组合在一起，并将其输出到文件**master**中：

```sh
$ xargs cat < filename > master
# 也可以为
$ xargs < filename cat > master
```
为了查看命令执行过程，可以使用`-t`选项显示每条命令。

----------
# Reference

[1] Haeley Hahn. Unix & Linux 大学教程[M]. 张杰良, 译. 北京:清华大学出版社, 2010.1:679-692.

