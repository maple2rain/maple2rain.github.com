---
layout: post
author: LPF
title: Linux命令之tr
date: 2017-05-22 11:39:38
updated: 2017-05-22 12:35:26
tags:
- Linux Command
categories:
- Study
- Computer
- OS
- Linux
- Command
---
> 转换字符也是经常做的一件数据处理事项。

`tr`(translate)程序可以对字符执行3中不同的运算：

- 将字符改变成其他字符
- 将连续字符用一个单独的字符代替
- 删除指定的字符

# 用法

`tr`程序的语法为：

```sh
$ tr [-cds] [set1 [set2]]
```

其中*set1*和*set2*是字符组。
注意该语法并不要求指定输入或输出文件名。这是因为`tr`是一个纯过滤器，只从标准输入读取数据，并向标准输出写入数据。如果希望从文件读取数据，必须重定向标准输入；如果希望将结果写入到文件中，则必须重定向标准输出。

`tr`程序执行的基本运算就是转换。在转换时需要指定两组字符。`tr`读取数据后，他查找第一组数据。当`tr`查找到读取的字符时，就使用第二组中对应的字符替换这些字符。
例如，假设您有一个文件*old*，您希望将所有的字符*a*替换为*A*。完成该任务的命令为：

```sh
$ tr a A < old
```

为了保存输出，只需将输出重定向到某个文件，如：

```sh
$ tr a A < old > new
```

通过定义较长的字符组，可以同时替换多个字符。下述命令查找并进行3中不同的替换：*a*替换为*A*，*b*替换为*B*，*c*替换为*C*：

```sh
$ tr abc ABC < old > new
```

如果第二组字符比第一组字符少，那么第二组中最后一个字符就是重复的。例如，下述两条命令是等价的：

```sh
$ tr abcde Axxxxx < old > new
$ tr abcde Ax     < old > new
```
这条命令将*a*替换为*A*，其他4个字符替换为*x*。
当指定对shell有特殊含义的字符时，需要使用引号引用他们。如果之引用一个单独的特殊字符，可以只使用反斜线引用。
假如您希望将所有的冒号、分号和问号改变成点号，则可以使用：

```sh
$ tr ':;?' \. < old > new
```

----------


# 指定范围

`tr`的强大缘于他能够处理字符范围。例如，考虑下述命令，该命令将所有的大写字母改变成小写字母：

```sh
$ tr ABCDEFGHIJKLMNOPQRSTUVWXYZ \
    abcdefghijklmnopqrstuvwxyz \
    < old > new
```

如上所示，大写字母和小写字母的对应是明确的，但是键入整个字母表两次较为犯人。作为替代，可以使用连字符**-**根据下述语法定义一个字符范围：

*start* **-** *end*
其中*start*是字符范围的第一个字符，*end*是字符范围的最后一个字符。
例如，上述例子可以重写为：

```sh
$ tr A-Z a-z < old > new
```

范围可以是任意希望的字符组，只要他们在所使用的排序序列中形成一个连续的序列即可。如数字**0-9**等。
为了方便起见，还可以使用正则表达式来代替他们，如**[:alpha:]**表示字母，**[:digit:]**表示数字，**[:lower:]**表示小写字母，**[:upper:]**表示大写字母等。
例如，下述两条命令是等价的：

```sh
$ tr A-Z a-z < old > new
$ tr [:upper:] [:lower:] < old > new
```

下述两条命令也是等价的：

```sh
$ tr 0-9 A-I < old < new
$ tr [:digit:] A-I < old > new
```

----------


# 转换不可显示字符

同样，`tr`程序可以转换不可显示字符，如制表符等，如下：

|代码|控制键|八进制码|名称|
|---|
|\b|^H|\010|退格|
|\t|^I|\011|制表符|
|\n|^J|\012|新行/换行|
|\r|^M|\015|回车|
|\\|-|-|反斜线|

比如，在不同系统，使用不同的符号标记换行，如Unix为**^J**，Mactintosh为**^M**。假设现在有一个文本文件*macfile*，在这个文件中每行以回车结尾，希望将其改变为Unix格式，即将回车改变成新行，并将输出保存在文件*unixfile*中，下述两条命令都可以完成这个任务：

```sh
$ tr '\r' '\n' < macfile > unixfile
$ tr '\015' '\012' < macfile > unixfile
```

# 高级话题

----------


## 挤压

`-s`选项告诉`tr`第一组中的多个连续字符应该替换为一个单独的字符，这种方式称为挤压。
例如，假设您希望将所有数字替换为字母*x*，输入来自文件*old*，输出写出到文件*new*：

```sh
# 将12345替换为xxxxx
$ tr [:digit] x < old > new
# 将12345替换为x
$ tr -s [:digit] x < old > new
```

一个更有趣的例子是，将连续的空格替换为一个单独的空格，这样做的方法为使用一个空格替换一个空格，同时挤压额外的空格：

```sh
$ tr -s ' ' ' ' < old > new
```

----------


## 删除指定字符

`-d`选项指定删除的字符。
例如，为了删除左右圆括号，可以使用：

```sh
$ tr -d '()' < old > new
```

为了删除所有数字，可以使用：

```sh
$ tr -d [:digit:] < old > new
```

----------


## 反向匹配

`-c`选项最复杂，同时功能也最强大。该选项告诉`tr`匹配不在第一组中的字符。
例如，下述命令将除空格和新行字符之外的所有字符都替换为*X*：

```sh
$ tr -c ' \n' X < old > new
```

该命令的效果就是保留文本的影像却不保留文本的含义，例如，假设文件*old*包含：

```sh
Be yourself. Everyone else is already taken.
```

那么上述命令将生成：

```sh
XX XXXXXXXXX XXXXXXXX XXXX XX XXXXXXX XXXXXX
```

同样，为了将文本中的非字母删去，可以反向匹配字母的方式，如下：

```sh
$ tr -cd [:alpha:] < old > new
```

但上述命令会将空格也一并删除，所以可以在添加过滤空格：

```sh
$ tr -cd '[:alpha:] ' < old < new
```

如果存在多个空格，还可以对其进行挤压：

```sh
$ tr -cds '[:alpha:] ' ' ' < old > new
```

----------

## 统计文章单词数量

为了统计文章数量，可以使用如下策略

1. 使用`cat`组合文件
2. 使用`tr`将每个单词放在一个单独行上
3. 使用`sort`对行进行排序，并消除重复行
4. 使用`wc`统计剩余行的数量

假设单词由53个不同字符组成：26个大写字母、26个小写字母以及撇号(即单引号)，每一行以新行符号**\n**结尾。
使用命令如下：

```sh
$ cat file... | tr -cs [:alpha:]\' "\n" | sort -fu | wc -l
```
- `tr`程序将所有不是字母或者撇号的字符替换为新行字符
- `sort`程序忽略大小写并去除重复行(即去除重复单词)
- `wc -l`统计行数

----------

# Reference

[1] Haeley Hahn. Unix & Linux 大学教程[M]. 张杰良, 译. 北京:清华大学出版社, 2010.1:433-439.