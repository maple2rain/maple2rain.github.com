---
layout: post
author: LPF
title: const
date: 2016-11-11 21:55:29
updated: 2017-02-21 16:01:04
tags:
- C++
categories:
- Study
- Computer
- PL
- C++
- Function
---
# 1 标准参数传递

当传递一个参数时，首先选择按引用传递，而且是`const引用`。

- 对于客户程序员来说，这样做语法与按值传递是一样的，所以不会像使用指针那样的混淆
- 对于函数的创建者来说，传递地址总比传递整个对象更有效

由于引用的语法原因，把一个临时对象传递给接收`const引用`的函数是可能的，因为编译器默认把临时对象设置为`const`，但不能把一个临时对象传递给接收指针的函数——对于指针，他必须明确地接收地址。

# 2 类里的const

对于类的`const`变量，初始化的地方应在构造函数的初始化列表中。因为`const`必须在建立他的地方被初始化，所以在构造函数的主体里，`const`必定已被初始化了，故必须在初始化列表中对其进行初始化。

# 3 编译期间类里的常量

类里普通的`const`并不足以成为一个在编译期间的常量成员。因为他需要在构造时进行赋初值。这就要求使用关键字`static`，其意味着`不管类的对象被创建多少次，都只有一个实例`。这恰好是所需要的：`类中的一个常量成员，在该类的所有对象中它都一样`。因此，一个内建类型的`static const`可以看做是一个编译期间的常量。
必须注意的是，在定义`static const`的地方就应该对其进行初始化。
如下在类中创建数组的例子：

```c++
class Stack{
    static const int size = 100;
    int stack[size];
    //...
};
```

在上述例子中，`size`实际上是一个编译期间常量，但隐藏在类中，此时可以将其用来定义数组的大小。

另外一种定义类中数组的方式是使用`enum`。如下：

```c++
class Stack{
    enum { size = 100; }
    int stack[size];
};
```

上述的`enum`保证不占用对象的存储空间，编译期间得到枚举值。

# 4 const对象和成员函数

如果声明一个成员函数为`const`，则等于告诉编译器该成员函数可以为一个`const`对象所调用。一个没有被明确声明为`const`的成员函数被看成是将要修改对象中数据成员的函数，而且编译器不允许他为一个`const`对象所调用。
重申函数为`const`，即将修饰符`const`放在函数参数表的后面，并且必须将`const`用同样的方式重复出现在定义里，如：

```c++
class X{
    int i;
public:
    X();
    int foo() const;//重申函数为const
};

int X::foo() const { return i; }//重申函数为const
```

一个`const`成员函数调用`const`和`非const`对象是安全的，但不修改数据成员的任何函数都应该把他们声明为`const`，这样他可以和`const`对象一起使用。

但有时希望建立一个`const`成员函数，不过仍然想在对象里修改某些数据。这时，可以在类声明里使用`mutable`关键字，以指定一个特定的数据成员可以在一个`const`对象里被改变。如：

```c++
class Y{
    mutable int i;//指定为const可修改
public:
    Y();
    void foo() const;
};

void Y::foo() const {
    i++;//在const函数中修改成员
}
```