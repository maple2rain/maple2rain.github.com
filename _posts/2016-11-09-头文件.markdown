---
layout: post
author: LPF
title: 头文件
date: 2016-11-09 17:46:19
updated: 2017-02-22 20:31:23
tags:
- C++
categories:
- Study
- Computer
- PL
- C++
---
# 1 头文件标准

对于包含结构的每个头文件，应当首先检查这个头文件是否已经包含在特定的`cpp`文件中。这可以通过测试预处理器的标记来检查。
如果这个标记没有设置，这个文件没有包含，则应当设置他，并声明这个结构，否则忽略声明代码。头文件标准定义如下：

```cpp
#ifndef HEADER_FLAG
#define HEADER_FLAG
// declaration...
#endif //HEADER_FLAG
```

或者，可以使用只编译一次的形式来通知文件已包含头文件，形式如下：

```cpp
#pragma once //put in the begin of file
```

# 2 命名空间

为了解决人类能相处的名字太少，而在协作时导致变量或函数名字重复的问题，引入了`名字空间`的概念，规定自己所用的库函数或变量就是在该名字空间定义的，从而避免不必要的冲突。
通常的形式如下：

```cpp
#include <iostream>
#include "myLib.h"
std::cout << "namespace: use std" << std::endl;
myLib::cout << "namespace: use myLib" << myLib::endl;
```

这样，用户可以指明所使用的`cout`来源于不同的实现库。

## 2.1 创建名称空间

为了使用名称空间，首先应该创建该名称空间，如上述的`myLib`，创建的方式如下：

```c++
//:myLib.h
namespace myLib{
    //Declarations
}
```

需要注意的几点是：

- `namespace`只能在全局范围内定义，但他们之间可以互相嵌套
- 在`namespace`定义的结尾，右花括号的后面不必跟一个分号
- 可以按类的语法定义一个`namespace`，定义的内容可在多个肉文件中延续，就好像重复定义这个`namespace`一样
- 一个`namespace`的名字可以用另一个名字来作他的别名，如`namespace std = standard;`



上述的`std`是环绕整个标准`C++`库的名字空间，所以这个特定的使用命令允许不用限定方式使用标准`C++`库中的名字。

## 2.2 未命名的名字空间

每个翻译单元都可包含一个未命名的名字空间，在这个空间中的名字自动地在翻译单元内无限制地有效，但要确保每个翻译单元只有一个未命名的名字空间。
如果把一个局部名字放在一个未命名的名字空间中，不需要加上`static`说明就可以让他们作`内部连接`。

使用方法如下：

```c++
//:UnnamedNamespace.cpp
namespace {
    class A { /* ... */ };
    class B { /* ... */ };
    int i, j, k;
}

int main() {} 
///:~
```

## 2.3 友元

可以在一个名字空间的类定义之内插入一个友元声明，这样函数就可以成为名字空间的一员，如下：

```c++
namespace Me{
    class Us{
        //...
        friend void you(); //you成为了名字空间中的一员
    };
}
```

## 2.4 使用名称空间

在一个名字空间中引用一个名字可以采取两种方法：

1. 使用作用域运算符
2. 使用`using`指令把所有名字引入到名字空间中

### 2.4.1 作用域运算符

名字空间中的任何名字都可以用作用域运算符作明确地指定，就像引用一个类中的名字一样。
如前文中的名字空间`myLib`，若其中有类`X`，则使用如下方式可引用类：

```c++
myLib::X a;//实例化类X对象a
``` 

### 2.4.2 使用指令

使用`using `关键字可以让我们立即进入整个名字空间，摆脱输入一个名字空间中完整标识符的烦恼，如上述，每次都需要`myLib::`前缀。这种`using`和`namespace`关键字的搭配使用称为`使用指令(using directive)`。如下所示：

```cpp
using namespace std; // 将名称空间std包含在当前范围内
```

## 2.5 不要在头文件使用指令

尽管使用指令可以减去很多麻烦，但这样的使用指令是会去除对该特定命名空间的保护，并且这个结果一直持续到当前编译单元结束。如果将一个使用指令放在一个头文件中，这就意味着`名字空间保护`将在包含这个头文件任何文件中小时，从而仍然会造就命名冲突问题。
简而言之，不要在头文件中放置使用指令。