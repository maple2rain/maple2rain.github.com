title: 关于printf用%f输出整数时为0的问题分析
date: 2016-10-30 13:25:34
updated: 2017-02-21 16:14:42
tags:
- CQuetion
categories:
- Study
- Computer
- PL
- C
---

## 1 问题描述
可能有时候会闲着无聊，就想要试试printf试着不同参数在不同格式下的输出结果。就在某一次无意操作中，当用%f格式输出整数1时，发现终端显示结果为0.000000，这是为什么呢？

------

## 2 解惑“1以%f格式输出时显示为0.000000”
问题已经出现了，为什么会有这么奇葩的结果呢？原因就是，浮点数与整型数的存储方式是不一样的。

### 2.1 IEEE754标准浮点数存储方式
在二进制科学表示法中，value=(-1)^S * (1.M) * 2^(E-Offset)，主要由三部分构成：符号位(S) + 阶码(E) + 尾数(M)。

- 符号位(Sign):0代表正，1代表负
- 指数位(Exponent):用于存储科学计数法中的指数数据，并且采用移码形式存储。
- 尾数(Mantissa):尾数部分

    |  类型  |   符号位位数    |       阶码位数      |      尾数位数      | 总位数 | 偏置值 |
    |--------|-----------------|---------------------|--------------------|--------|--------|
    | float  | 占1位，在第31位 | 占8位，在第30~23位  | 占23位，在第22~0位 |     32 | 0x7F   |
    | double | 占1位，在第63位 | 占11位，在第62~52位 | 占52位，在第51~0位 |     64 | 0x3FF  |

- 阶码
    
    阶码即指数位，采用移码形式存储。简单的理解，阶码就是将数值以二进制科学表示法表示时，此时它的阶数即为阶码值。
    不过，阶码值是由偏置值(Offset)加上阶码真值确定的，因为指数是有正负数的。
    -  对于float类型数据，其偏置值为127，表示阶数范围为-128~127；
    - 对于double类型数据，其偏置值为1023，表示阶数范围为-1024~1023.

- 尾数
    
    有数是有效数值位，存储了数值转换为二进制科学计数法的尾数值，用原码表示。

- 移码

    移码是符号位取反的补码，引入的目的是为了保证浮点数的机器零为全零。
    当用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。而实际上这个数是无限接近于零的，此时就需要取出“-0”作为机器零，这样就显得很别扭。

### 2.2 举例说明
将float型十进制100.25转换为浮点数格式

- 把十进制数转换成二进制数
(100.25)<font size=1>10</font>=(1100100.01)<font size=1>2</font>

-  将二进制数以科学计数法表示
1100100.01 = 1.10010001 * 2^6

- 计算出阶码的移码(偏置值 + 阶码真值)
0x7F + 0x06 = 0x85 = (10000101)<font size=1>2</font>

- 以短浮点数格式表示该数
    + 符号位 = 0
    + 阶码 = 1000,0101
    + 尾数 = 1001,0001,0000,0000,0000,000

- 得到短浮点数
0;1000,0101;1001,0001,0000,0000,0000,000

- 在内存中，其存放方式为

    |  高地址  |          |          |  低地址  |
    |----------|----------|----------|----------|
    | 01000010 | 11001000 | 10000000 | 00000000 |

由短浮点数转换为十进制数即为其逆过程。

### 2.3 浮点数规则
为了表示一些特殊数值，E的最小值0和最大值255将留作他用。有以下规则

- 当E不全为0或不全为1时(即除掉最小值或最大值的情况)
    
    这时，浮点数就采用上面的规则表示。

- 当E全为0时
    
    这时，浮点数的指数等于1 - 127或1 - 1023，此时表示的是0或者是接近于0的很小的小数。
    若M为0，则表示为机器零。

- 当E全为1时

    如果有效数字M全为0，则表示为正负无穷大；如果有效数字M不全为0，则表示这个数不是一个数(NaN)。

------
## 3 又一奇葩问题
此时，你十分兴奋的想要执行以下语句

```cpp
int hex = 0xffff;
printf("%f, 0x%x\n", 1, hex);
```

执行结果
![](../post_img/58158fb0ab644162e1004296)
你却发现，不但没有输出**1.000000**(%f默认保留6位小数)，而且后面输出的值也变得不是**0xffff**了，这又是什么奇葩的原因呢？

### 3.1 问题探讨
上述问题的原因就要追溯到printf是如何实现的了。众所周知，printf的参数时可变参数，可变的参数的好处就是可以灵活运用，以此来做自己需要的很灵活的函数。但是其缺点也是非常明显的，就是当你参数输入错误的时候，可能就会触发隐藏的问题，就如上面所述的那样。那么，printf又是如何实现的？

------

## 4 printf实现原理
欲实现具有可变参数的printf，首先我们得知道可变参数是什么。

### 4.1 可变参数
所谓可变参数，就是函数中的参数是非固定、可变的，如printf函数的原型,

```cpp
int printf( const char* format, ...);
```

其中，固定参数是字符串format，表示一个可变参数列表，而其中的可用的可变参数用**...**表示。

### 4.2 可变参数实现原理
若想实现可变参数，需要用到<stdarg.h>中定义的几个宏。C语言用宏来处理这些可变参数。这些宏看起来很复杂，其实原理挺简单，就是根据参数入栈的特点从最靠近第一个可变参数的固定参数开始，依次获取每个可变参数的地址。下面我们来分析这些宏。在VC中的stdarg.h头文件中，针对不同平台有不同的宏定义，我们选取X86平台下的宏定义：

```cpp
//stdarg.h
#define va_start __crt_va_start
#define va_arg   __crt_va_arg
#define va_end   __crt_va_end

//vadefs.h
typedef char* va_list;

#define _ADDRESSOF(v) (&(v))
#define _INTSIZEOF(n)          ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1))
#define __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v)))
#define __crt_va_arg(ap, t)     (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))
#define __crt_va_end(ap)        ((void)(ap = (va_list)0))
```

#### 4.3 宏的功能

#####4.3.1 va_list
    
首先要弄清楚va_list是什么。它不是一个宏，它用于声明一个变量，而这个变量其实是一个字符串，因此它被声明为字符型指针，这个类型用于声明一个指向参数列表的字符型指针变量。

#####4.3.2 va_start(ap, v)  
```c
#define __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v)))
```
它的第一个参数*ap*是指向可变参数字符串的变量，第二个参数*v*是可变参数函数的第一个参数，即固定参数，通常用于指定可变参数列表中参数的个数，或像printf一样的格式控制字符串。


* 首先， 先取出第一个固定参数的地址*(va_list)_ADDRESSOF(v)*
* 其次，将取得的地址指针移动，即跨过固定参数得到第一个可变参数的地址*+ _INTSIZEOF(v))*
* 最后，将其赋值给ap，即得到第一个可变参数的地址

#####4.3.3 va_arg(ap, t)

它的第一个参数*ap*指向可变参数列表的变量，第二个参数是可变参数的类型。它的主要功能是从*ap*中取出下一个参数的值。

```c
#define __crt_va_arg(ap, t)     (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))
```

 + 本来，ap指针已经指向了当前的参数的地址
 + 但此时，ap指针指向下一个参数的地址*ap += _INTSIZEOF(t))*
  + 这么做的原因是C语言的函数是从右向左压入堆栈的，从而靠右的参数在高地址
  + 且这样就保证了*ap*不断指向下一个参数的地址
 + 其次，再减去下一个参数所占的字节数，即重新得到当前参数的地址
 + 最后，将其强制转换后，便可得到参数值了

#####4.3.4 va_end(ap)
将声明的ap指针置为空，因为指针使用后最后设置为空。

```c
#define __crt_va_end(ap)    ((void)(ap = (va_list)0))
```

#####4.3.5 关于_INTSIZEOF(n)

```c
#define _INTSIZEOF(n)      ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1))
```
_INTSIZEOF(n)整个做的事情就是将n的长度化为int长度的整数倍。
在这里是采用以int所占的字节为标准进行对齐操作。

 + 举个例子

    比如n为5，二进制就是101b，int长度为4，二进制为100b，那么n化为int长度的整数倍就应该为8。
    ~(sizeof(int) - 1) )就应该为~(4 - 1)=~(00000011b)=11111100b，这样任何数& ~(sizeof(int) - 1) )后最后两位肯定为0，就肯定是4的整数倍了。
    
    (sizeof(n) + sizeof(int) - 1）就是将大于4m但小于等于4(m + 1)的数提高到大于等于4(m + 1)但小于4(m + 2)，这样再& ~(sizeof(int) - 1) 后就正好将原长度补齐到4的倍数了。 

------

## 5 问题重述
再回到刚才那个奇葩问题，既然已经知道浮点数格式表示法和可变参数的实现原理了，那自然而然就可以清楚刚才那个问题的原因了。

- 首先，编译器自动辨认数值常量*1*，并将他以**int**型方式存储，在参数压栈的时候，占用4字节的空间(在32位机器上)
- 然而，**printf**格式字符串**%f**需要类型**double**的参数，此时它将会读取8个字节的数据(double类型占8个字节)
- 从而，他多读取了属于hex的数据，而在读取hex时多读取了其他空间的数据
- 所以，结果就是我们所考到的那样是*0.000000*和随机值

### 5.1 验证一下
现在知道了原因之后，再来验证一下 ，尝试求出某个小数的浮点数存储二进制表示，如下所示
![](../post_img/58158fb0ab644162e1004295)
- 其中，*0x4059100000000000*是*100.25*的浮点数二进制存储方式