title: 磁盘调度策略
date: 2016-11-02 17:02:57
updated: 2017-02-21 16:12:19
tags:
- Disk
categories:
- Study
- Computer
- OS
- Memory
---
# 1 概念
> 磁盘的读取效率很大程度上取决于寻道时间。

- 当文件顺序组织在磁盘上时，磁盘操作读取时间可限于一次寻道时间及多次读取扇区的时间
- 当进行随机访问时，几乎每一次读取操作都需要重新进行一次寻道

如果扇区访问请求包括随机选择磁道，则磁盘**I/O**的性能会非常低。为提高性能，需要减少花费在寻道上的时间。

## 1.1 随机访问的情况
出现随机访问磁盘的情况有两种：

- 文件被随机组织放置在磁盘中，导致程序在读取该文件时不得不进行随机操作（解决方案是在写入文件时**按簇写入**）
- 在多道程序设计环境中，操作系统为每个**I/O**设备维护一条请求队列。因此对每一个磁盘，队列中可能有来自多个进程的许多**I/O**请求。如果随机地从队列中选择项目，那么磁道完全是被随机访问的

# 2 磁盘调度策略

## 2.1 根据请求者选择

> 首先介绍基于队列或请求者属性的调度

### 2.1.1 先进先出(FIFO)

最简单的调度是**先进先出**，这意味着按顺序处理队列中的项目。这个策略具有公平的有点，因为每一个请求都会得到处理，并且是按照接收到的顺序进行处理的。
使用**FIFO**，如果只有一些进程需要访问**I/O**，并且如果大多数请求都是访问簇聚的文件扇区，则有望达到较好的性能。但如果有大量进程竞争一个磁盘，那么这种技术在性能上往往接近于**随机调度**。

### 2.1.2 优先级(PRI)

对于**基于优先级**的系统，有关调度的控制在磁盘管理软件的控制之外。这种方法并不会优化磁盘的使用率，但可以满足操作系统的其他目标。通常比较短的批作业和交互作业的优先级较高，而较长计算时间的长作业的优先级较低。这就使得大量的短作业能够迅速地通过系统，并且可以提供比较好的交互响应时间。
但是，这样一来，长作业不得不等待过长的时间。此外，这种策略可能会导致部分用户采用对抗手段：把作业分成小块，以回应系统的这种策略。
对于数据库系统，这类策略往往导致性能较差。

### 2.1.3 后进先出(LIFO)

在事务处理系统中，把设备资源提供给最近的用户，会导致磁头臂在一个顺序文件中移动时移动得很少，甚至不移动。利用这种局部性可以提高吞吐量，减小队列长度。只要一个作业积极地使用文件系统，他就可以尽可能快地得到处理。
但是如果工作量大而使磁盘保持忙状态，就有可能出现饿死的情况。当一个作业已经往队列中送入一个**I/O**请求，并且错过了可以提供服务的位置时，该作业就有可能永远得不到服务，除非他前面的队列为空。

## 2.2 根据被请求项选择

> 如果调度器知道程序欲访问磁道位置，就可以采用基于被请求项的调度策略

### 2.2.1 最短服务时间优先(SSTF)

**SSTF**策略选择使磁头臂往当前位置开始移动最少的磁盘**I/O**请求。因此，其总是选择导致最小寻道时间的请求。
但是，总是选择最小寻道时间并不能保证平均寻道时间最小。不过，他可以提供比**FIFO**更好的性能。
由于磁头臂可以同时向两个方向移动，因此可以使用一种随机选择算法解决距离相等的情况。

### 2.2.2 扫描(SCAN)

除了**FIFO**，以上讨论的策略都可能使某些请求直到整个队列为空时才可以完成，为避免出现这类**饿死**的情况，一种简单的方法是**SCAN**算法。

**SCAN**要求磁头臂仅仅沿一个方向移动，并在途中满足所有未完成的请求，直到他到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止**(LOOK策略)**，接着反转服务方向，沿相反方向扫描，同样按顺序完成所有请求。
值得注意的是，**SCAN**算法对最近横跨过的区域不公平，即他不会去服务**I/O**请求在刚刚经过的磁道，因此，他在开发局部性不如**SSTF**和**LIFO**好。
同时，不难看出，**SCAN**策略偏爱请求靠近最里或最外的磁道的作业**(磁头会在很短时间内往返经过最里或最外磁道)**，并且偏爱最近作业**(在新的作业的请求磁道出现在靠近当前磁头位置时，会被很快处理)**。第一个问题可以通过**C-SCAN**策略得以避免，第二个问题可以通过**N-Step-SCAN**策略解决。

### 2.2.3 循环扫描(C-SCAN)

**C-SCAN**策略把扫描限定在一个方向。
因此，当访问到沿某个方向上的最后一个磁道时，磁头臂返回到磁盘相反方向磁道的末端，并再次开始扫描。
这种方式减少了新请求的最大延迟。
如果从最里到最外磁道扫描的期望时间为*t*，则采用**SCAN**策略时，扇区的期望服务时间间隔为**2t**，而对于**C-SCAN**，这个间隔约为**t + $s_{max}$**，其中$s_{max}$是最大寻道时间。

### 2.2.4 N-Step-SCAN和FSCAN

对于**SSTF、SCAN、C-SCAN**，磁头臂可能在一段很长时间内不会移动。
例如，如果一个或多个进程对一个磁道有较高的访问速度时，他们可以通过重复地请求这个磁道以垄断整个设备。高密度多面磁盘比低密度磁盘以及单面或双面磁盘更容易受这种特性的影响。为避免这种**磁头臂的粘性**，磁盘请求队列被分成段，一次只有一段被完全处理。

- N-Step-SCAN

    **N-Step-SCAN**策略把磁盘请求队列分成长度为**N**的子队列，每一次用**SCAN**处理一个子队列。
    在处理某一个队列时，新请求必须添加到其他某个队列中。
    如果在扫描的最后剩下的请求数小于**N**，则他们全都在下一次扫描时被处理。
    
    - 对于比较大的**N**值，**N-Step-SCAN**的性能接近于**SCAN**
    - 当**N**为1时，实际上就是**FIFO**
    
- FSACN

    **FSACN**是一种使用两个子队列的策略。
    
    - 当扫描开始时，所有请求都在一个队列中，而另一个队列为空
    - 在扫描过程中，所有新到的请求都被放入另一个队列中
    
    从而，对新请求的服务延迟到处理完所有旧请求之后。

## 2.3 磁盘调度算法对比

下列是上述各种调度算法的说明及特点对比表。

|名称|说明|特点|
|---|
|RSS|随机调度|用于分析和模拟|
|FIFO|先进先出|最公平的调度|
|PRI|进程优先级|在磁盘队列管理之外控制|
|LIFO|后进先出|局部性最好，资源的使用率最高，队列小|
|SSTF|最短服务时间优先|局部性较好|
|SCAN|在磁盘上往复扫描|服务分布比较好|
|C-SCAN|一条道路，快速返回|服务变化比较低|
|N-Step-SCAN|一次N个记录的SCAN|服务保证|
|FSCAN|使用两个子队列的SCAN|负载敏感|


# 3 Linux磁盘调度

## 3.1 电梯调度器

电梯调度器为磁盘读写请求保持一个队列，并且在该队列上执行排序和合并功能。一般情况下，电梯调度器通过块号对请求队列进行排序。因而，当磁盘请求被处理的时候，磁盘驱动向一个方向移动，以满足其在该方向上遇到的每个请求。通常可以按如下方式总结。在一个新的请求添加到队列中时，会依次考虑四个操作：

1. 如果新的请求与队列中等待的请求的数据处于同一磁盘扇区或相邻的扇区，则将现有请求和新请求合并成一个请求
2. 如果队列中的请求已经存在很长时间，则新的请求将被插入到队列的尾部
3. 如果没有合适的位置，则新的请求将被插入到队列的尾部

上述第2个操作是为了防止请求长时间得不到满足，但这并不十分有效，因为该方式并没有试图为服务请求提供一个时间限定的框架，只是在一个合理的延迟后停止插入排序的请求。
从而导致两个问题：
1. 由于队列动态更新的原因，一个相距较远的请求可能会延迟相当长的时间
2. 考虑到读与写请求的不同，还有一个更严重的问题。由于写请求是异步的，即一旦进程发出了写请求，其不必等待该请求被实际执行即可进行运行。内核将数据复制到一个合适的缓冲区，并在一定时间后自动将数据写进磁盘。但对于读操作，进程必须等待，直到所请求的数据在应用程序运行前发送给应用程序。这样一来，一个写请求的流(如想磁盘写一个大文件)可以堵塞一个读请求很长时间，从而堵塞进程

## 3.2 时限调度器

为了克服电梯调度器的饥饿和读写不一致问题，时限调度器使用了三个队列。
每个新来的请求被放置到排序的电梯队列中，并且，同样的请求根据类型被放置在一个**FIFO读队列**或**FIFO写队列**中。这样，读和写队列维护了一个按请求发生时间为顺序的请求列表。
对每一个到期时间，对于读请求默认值为0.5s，对于写请求默认值为5s。
通常，调度器从排序队列中分派服务。当一个请求得到满足时，其将从排序队列的头部移走，同时也从对应的**FIFO**移走。然而，当**FIFO**队列头部的请求项超过到期时间时，调度器将从该**FIFO**中派遣任务，取出到期的请求，再加上接下来的几个队列中的请求。当任一个请求被服务时，其也从排序队列中移出。

## 3.3 预期I/O调度器

典型情况下，一个应用程序会在一个读请求得到满足并且数据可用之后，才会发出一个读请求。在接受上次读请求的数据和发出下一次读请求之间会有一个很小的延迟，利用这个延迟，调度器可以转向其他等待的请求，并服务该请求。
但由于局部性原理，相同进程的连续读请求会发生在相邻的磁道上。如果调度器在满足一个读请求后延迟一小段时间，看看是否有新的有新的附件的读请求，则可以增强整个系统的性能。
在**Linux**中，预期调度器是对实现调度器的补充。当一个读请求被分派时，预期调度器会将调度系统的执行延迟6ms，具体时间取决于配置文件。在这一小段延迟中，发出上一条读请求的应用程序有机会发出另一条读请求，并且该请求发生在相同的磁盘区域内。如果是这样，新的请求会立刻享受服务，否则，调度器继续使用时限调度算法。