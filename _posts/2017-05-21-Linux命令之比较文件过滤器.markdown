---
layout: post
author: LPF
title: Linux命令之比较文件过滤器
date: 2017-05-21 11:27:38
updated: 2017-06-11 11:45:20
tags:
- Linux Command
categories:
- Study
- Computer
- OS
- Linux
- Command
---
> 多年来，Unix程序员创建了大量的工具来帮助回答下述问题：
两个文件是否包含完全相同的数据？如果不相同，那么这两个文件之间的区别是什么？
在本篇文章中，将介绍这些比较文件的工具。


# 概述

|过滤器|作用|文件类型|文件数量|
|---|
|cmp|比较两个文件|二进制或文本|2|
|comm|比较两个有序文件，显示区别|文本：有序|2|
|diff|比较两个文件，显示区别|文本|2|
|sdiff|比较两个文件，显示区别|文本|2|
 
 

----------


# 比较任意两个文件：cmp

`cmp`的使用只有一种情形：查看两个文件是否相同。`cmp`程序的语法为：

```sh
$ cmp file1 file2
```
其中，*file1*和*file2*是文件的名称。
`cmp`程序逐字节地比较两个文件，查看两个文件是否相同。如果两个文件中对于的字节完全相同，那么这两个文件就是相同的，那么`cmp`程序将不会输出消息。否则，`cmp`程序将显示一个合适的消息，如下：

```sh
$ cmp file1 file2
file1 file2 differ: byte 2, line 1
```

消息的意思为，两个文件在第1行第二个字节处存在首处不同。

因为`cmp`程序每次一个字节地比较文件，所以他不关心文件是什么类型的，因此他可以比较任何类型的文件：文本或者二进制文件。

----------

# 比较有序文本文件：comm

`comm`程序一行一行地比较两个有序的文件。当有两个相似的文件，并且希望查看他们之间的区别时，可以使用`comm`程序。`comm`程序的语法为：

```sh
$ comm [-123] file1 file2
```

其中，*file1*和*file2*是文件的名称。
`comm`程序的漂亮之处在于他允许查看两个文件之间的区别。该程序以3列显示输出：

1. 第一列包含在在第一个文件中有的行
2. 第二列包含只在第二个文件中有的行
3. 第三列包含两个文件中都有的行

如现在有两个文件*file1*及*file2*。
*file1*的内容为：

```sh
Curry
Durant
Thompson
```

*file2*的内容为：

```sh
Curry
Green
```

然后使用`comm`进行比较(注意，文件已有序)：

```sh
$ comm file1 file2
            Curry
Durant
        Green
Thompson
```

在上述输出中，显示第一列有两个名字，*Durant*和*Thompson*为*file1*所独有；显示第二列有一个名字，*Green*为*file2*所独有；显示第三列有三个名字，*Curry*为两个文件都包含。
此外，可以明显看到两个文件不同的准确位置，如上述是在第一个文件的第二行就存在不同。特别的，如果两个文件相似度很高，那么使用该程序就可以很快定位不同的地方了。
为了控制输出，`comm`程序允许使用`-1`、`-2`和`-3`选项分别抑制第一、第二和第三列。例如，可以选择使用`-e`选项抑制掉第三列输出，这将只看到两个文件的不同之处：

```sh
$ comm file1 file2 -3
Durant
        Green
Thompson
```

也可以不止抑制一列的内容，可以使用组合选项，如只希望显示相同处，那么可以抑制掉第一和第二列：

```sh
$ comm file1 file2 -12
Curry
```

> 提示
**comm**程序不按期望工作的最常见原因就是输入文件没有排序。如下提示：
comm: file 1 is not in sorted order

----------

# 抽取数据列：cut {#statusID}

`cut`程序是一个从数据中抽取指定列并将其他内容抛弃的过滤器(与`colrm`从数据中删除指定列并保存其他内容)。
当抽取数据列时，语法如下：

```sh
$ cut -c list [file...]
```

其中，*list*是要抽取的列的列表，*file*是输入文件的名称。
使用列表告诉`cut`希望抽取的列，可以指定一个或多个列号，各个列号用逗号隔开。列表中不能有空格。例如，如果希望抽取第10列，则使用**10**。如果希望抽取第1、8和10列，则使用**1,8,10**。
另外，还可以指定列的范围，即将开头和结尾的列号用连字符**-**连起来。例如，为了抽取第10列至第15列，可以使用**10-15**。为了抽取第1、8及10至15列，可以使用**1,8,10-15**。

例如，现在有一个**status**，里面记录了用户登录信息。其中，列1-5是用户标识，10-13是终端，23-38是时间等，其余则是空格等，内容如下：

```sh 
maple    tty1         2017-05-20 08:26
root     tty2         2017-05-21 14:43
```

为了只显示用户标识，可以使用：

```sh
$ cut -c 1-5 status
maple
root
```

为了用户和登录时间，可以使用(为了加空格区别，保留了用户标识后的空格)：

```sh
$ cut -c 1-6,23-38 status
maple 2017-05-20 08:26
root  2017-05-21 14:43
```

当然，还可以省略`-c`之后的空格。

----------


# 抽取数据段：cut

在上一节中，使用`cut`程序抽取指定的数据列。但是，`cut`还有另外一种应用：抽取数据段。为了理解这种工作方式，首先需要理解几个基本思想。
考虑下面两个不同文件。
第一个文件*status1*包含内容如下：

```sh
maple	tty1	2017-05-20 08:26
root 	tty2	2017-05-21 14:43
```

第二个文件*status2*包含内容如下：

```sh
maple|tty1|2017-05-20 08:26
root|tty2|2017-05-21 14:43
```

在两个文件中，每行都包含一个用户标识、终端和登录时间，实际上，这两个文件包含相同的信息，但是他们之间有很大的区别。
第一个文件容易阅读，因为信息按列对齐。第二个文件更适合于程序读取，因为**|**字符将每行分成3部分。我们称第一个文件是人类可读的，第二个文件是机器可读的。
当使用由程序处理的数据时，我们经常会遇到机器可读的文件。对于这种数据来说，每行都称为一个**记录(record)**，每行的各个部分称为**字段(field)**，而充当字段分隔符的字符称为**定界符(delimiter)**。在上述例子中，总共有2条记录，每条记录有3个字段，每个记录的定界符都是竖线**|**。
当然，定界符不止竖线。原则上，任何在实际数据中不出现的字符都可以用作定界符。最常见的定界符就是逗号、空格、制表符和空白符(空格和制表符的组合)。
当抽取字段时，`cut`程序的语法为：

```sh
$ cut -f list [-d delimiter] [-s] [file...]
```

其中，*list*是抽取字段的列表，*delimiter*是分隔字段所使用的定界符，而*file*是输入文件的名称。
与`-c`选项相比，字段列表的格式完全相似。可以指定一个或多个列号，各个列号用逗号隔开。列表中不能有空格。例如，如果希望抽取第10列，则使用**10**。如果希望抽取第1、8和10列，则使用**1,8,10**。
另外，还可以指定列的范围，即将开头和结尾的列号用连字符**-**连起来。例如，为了抽取第10列至第15列，可以使用**10-15**。为了抽取第1、8及10至15列，可以使用**1,8,10-15**。

例如，为了抽取*status2*每行的第1个字段，可以使用：

```sh
$ cut -f 1 -d '|' status
maple
root
```

如果希望抽取第1和第2个字段，可以使用：

```sh
$ cut stats -f 1,2 -d '|'
maple|tty1
root|tty2
```

如果`cut`遇到不包含任何定界符的行，那么他会默认地将整行输出。如果希望抛弃这样的行，可以使用个`-s`(suppress)选项。
同样，同`-c`选项一样，可以省略空格。
大多数有经验的Unix人士都省略空格。

> 提示
通常将定界符使用引号引用起来，这是个好习惯，可以确保在shell解析命令时不会错误的解释定界符。可以省略引号，但如果定界符是空格、制表符或元字符，则必须引用定界符。

----------


# 组合数据列：paste

`paste`程序用于组合数据列。这个程序拥有极大的灵活性，其可以将几个文件(每个文件都包含一列数据)组成一个达标。另外，也可以将连续的数据行组合起来，构建多个列。
`paste`程序的语法为：

```sh
$ paster [-d char...] [file...] [-s]
```
其中，*char*是用作分隔符(定界符)的字符，而*file*是输入文件的名称。
使用`paste`可以将各数据列组合成一个大表。如果需要，还可以将其重定向至文件中保存。下面举一个例子。
假设有3个文件*user*、*term*、*time*，分别存储用户标识、终端和登录时间，各个文件的内容如下所示：

文件*user*包含：

```sh
maple
root
```

文件*term*包含：

```sh
tty1
tty2
```

文件*time*包含：

```sh
2017-05-20 08:26
2017-05-21 14:43
```

假设希望将其组合成大文件*status*，将所有这些数据组合成一个单独的表，在这个表中，每个文件的数据都在应该属于自己的列中。所使用的命令为：

```sh
$ paste user term time > status
```

此时文件*status*的内容为：

```sh
maple	tty1	2017-05-20 08:26
root 	tty2	2017-05-21 14:43
```

默认情况下，`paste`在每两列之间放一个制表符字符。当然可以使用自己期望的分隔符，使用`-d`选项，后面跟一个在括在单引号中的备选字符。例如，使用空格隔开，可以使用：

```sh
$ paste -d ' ' user term time > status
```

此时文件*status*的内容为：

```sh
maple tty1 2017-05-20 08:26
root tty2 2017-05-21 14:43
```

如果指定了不止一个分隔符，那么`paste`将轮流使用每个分隔符，如果需要的话再重复使用各个分隔符，即轮转使用。例如，下述命令指定了两个不同的分隔符，一个竖线**|**和一个百分号**%**。

```sh
$ paste -d '|%' user term time >| status
```

此时文件*status*的内容为：
```sh
maple|tty1%2017-05-20 08:26
root|tty2%2017-05-21 14:43
```

> 提示
可以认为`paste`与`cat`相似。两者之间的区别在于`paste`水平组合数据，而`cat`垂直组合数据。

另外，倘若使用`-s`选项，则每一次则处理一个文件，而不是同时处理所有文件，即把每个文件的每一行都放在同一行，如对上述例子使用`-s`选项，输出如下：

```sh
$ paste user term time -s
maple	root 
tty1	tty2
2017-05-20 08:26	2017-05-21 14:43
```

可以通过灵活使用`cut`和`paste`程序，改变一个表中列顺序的位置。相信聪明的你已经发现*user*、*term*及*time*是从一开始的[status](#statusID)文件中抽取出各列而形成的内容。如果在`paste`例子中改变这三个文件的顺序，就可以以不同顺序组合表了，即灵活地改变各列的位置。

# Reference

[1] Haeley Hahn. Unix & Linux 大学教程[M]. 张杰良, 译. 北京:清华大学出版社, 2010.1:353-375.