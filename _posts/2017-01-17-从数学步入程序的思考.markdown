---
layout: post
author: LPF
title: 从数学步入程序的思考
date: 2017-01-17 21:35:55
updated: 2017-04-28 15:57:44
tags:
- Algorithm
categories:
- Life
- Thinking
---
## 最优之路

数学领域中有一本传说中的书——The Book，其在地球上任何一家图书馆都找不到，但在这本书中记录了所有数学的定理的最优证明。
那么，假如也有这么一本关于程序和算法的书，在书中也列出了每个可计算问题的最优解决方案。那么，此程序必须是正确的、易懂的、优雅的、简洁的且充满智慧的。
那么，是否存在这样一本算法书，或者说，是否存在`理想的程序`呢？

## 总有瑕疵

不管如何努力创造像上述中的算法艺术瑰宝，现实程序中总是会存在一些带有瑕疵的代码，无论如何努力都无法消除。即使这个程序能够产生正确的结果，但其中仍然存在一些勉强的和不自然的地方。
这些地方的逻辑是一团杂乱的特殊情况和异常;或者是程序的结构看上去非常脆弱。不过随后可能突然找到灵感，或者在他人展示的技巧中受到启发，从而获得可以记录进`The Book`的程序。

## 没有捷径

欧几里得曾经告诉一位高贵的学生：“学习几何学没有捷径”。在这些没有捷径的道路中，计算几何学这条路是非常泥泞的，布满了车辙并且崎岖不平。在这条路上，我们遇到的困难有时候是关于计算效率的问题：将程序的运行时间和内存消耗控制在合理的范围之内。但在此之上，更值得关心的是能不能把算法写正确？能不能使算法变得漂亮？
接下来将通过一个解决`三点共线`的问题，来逐渐步入从数学到程序的思考，明白所谓捷径并不存在，并最终找到可以入驻`The Book`的程序。

## 三点共线

### 直线方程

为了判断三点是否共线，在此可用的第一种方法是求出其中两点的直线方程，并判断第三个点的坐标是否满足这个直线方程。
直线方程的形式为$y = kx + b$，其中k为斜率，b为y轴截距。
因此，假设有三个点p、q和r，则可以首先算出连接其中两个点的直线的k和b值，然后用第三个点的x和y坐标值来判断是否满足同一个方程。

```c
// coordinate struct define
typedef struct Coord{
    double x;
    double y;
}Coord;

int isThreePointsCollinear_1(Coord p, Coord q, Coord r)
{
    double k = (p.y - q.y) / (p.x - q.x);   //slope
    double b = p.y - p.x * k;   // intercept
    
    return (r.y == (k * r.x + b));
}
```

上述算法在大多数情况下是正确的，然而，这个算法有一个死穴，那就是当存在有两个点相连时所形成的直线没有斜率时，此算法将出现*除零错误*。因为斜率的定义为$\frac{\Delta y}{\Delta x}$。而当p和q的x坐标相同时，$\Delta x$为0，从而得到*除零错误*。
在出现上述情况时，可以添加判断来筛选这个特殊情况，但显而易见的是，对垂直线的特殊处理势必让程序变得难看起来，这个补丁尽管只有一到两行。

### 不可靠的斜率

除了上述方法外，另外一个简单的算法则是直接比较斜率。只需绘制两条线，倘若其斜率相同或都不存在，那么这也可证明三点共线(而无需判断b值)。
这个算法看似要比上述算法高明一点，因为少了对b的计算及后期的依赖计算。然而，问题仍存在。
问题在于，当有其中两点具有相同坐标时，举个例子：

1. p(0, 0) q(0, 0) r(1 1)
2. p(0, 0) q(0, 0) r(0 1)

在这种情况下，这三点是否是共线呢？有观点是，这三点之间可以绘制一条简单的直线，因此是共线的;反对者认为，两个相同点之间可以绘制任意斜率的直线，故不共线。
且不论这三点是否共线，单纯从程序的运行结果来看，

- 对于第一种情况，将被认为是p和q不存在斜率，而p和r存在斜率，故不共线
- 对于第二种情况，将被认为是都不存在斜率，故共线

然而，无疑这种判断标准是病态的。也许可以添加约束条件来约束调用者，然而这并不美观。

### 三角不等性

从另一方面思考，若三点不共线，则三点将构成一个三角形。而三角形的一个特点即是任意两边之和大于第三边。当且仅当最长边之和等于其余两边之和时，三点共线。
这种方案只依赖与点之间的几何关系，而与这些点在平面上的位置和方向是独立的，且没有用到斜率和截距。此外，在有两个或者三个点相同的情况时，也会认为所有这样的点是共线的。
不幸的是，测量距离时是存在误差的。这是计算机数据存储精度受限的原因。当三点不共线，而是围成一个极小三角形时，该算法将认为三点共线。从而，此算法仍存在不完美。

### 通过面积

通过算法来得出三点是否共线，重点在于，当三点共线时，三点围成的三角形为退化三角形，此时面积为零。在其他情况下，面积都不为零。
这种方案的好处就是，无需求周长时需要用到平方根或其他无理数的运算。其次，更少地依赖数值的精度。
但如何计算面积呢？显然，传统的欧几里得公式$S = \frac{1}{2}bh$和三角方法都不是最佳答案。
更好的方法是把三角形的边视为矢量;从任何一个顶点发射出来的两个矢量定义了一个平行四边形，他的面积可以由两个矢量的叉乘获得。三角形的面积为该平行四边形的一半。
事实上，这种计算将取得`有符号的面积`：

- 如果三角形的顶点是按照逆时针的方向取的，那么结果是正的
- 如果三角形的顶点是按照顺时针的方向取的，那么结果是负的
- 但当所有顶点共线时，面积为零

计算面积的矢量公式可以被简单地表达为一个2 × 2的行列是：

$$
A = 
 \frac{1}{2}
 \begin{bmatrix}
   x_1 - x_3 & y_1 - y_3\\
   x_2 - x_3 & y_2 - y_3\\
  \end{bmatrix}
  = 
  \frac{1}{2}
  [(x_1 - x_3)(y_2 - y_3) - (x_2 - x_3)(y_1 - y_3)]
  \tag{1}
$$

由于只考虑行列式值为零的情况，所以可以忽略$\frac{1}{2}$这个系数，然后编码如下：

```c
int isThreePointsCollinear_2(Coord p, Coord q, Coord r)
{
    return (p.x - r.x) * (q.y - r.y) ==
            (q.x - r.x) * (p.y - r.y);
}
```

至此，算法算是完美结束，登入`The Book`大堂。

## 总结

为了求出三点是否共线，理论上的数学知识在绝大多数情况下都是够用的，但总是存在一些意外，让算法无功而返。而这，说穿了便是其健壮性不强，又或者为了健壮性而添加的保护措施使程序狼狈不堪。这便达不到优美代码的要求，也难得大雅之堂。而最终的理想程序，则是在一步步地纠错中，并在不断地从其他领域知识的潜移默化下才逐渐浮出水面。很难想象，一个没有基础知识的程序员如何写出真正优美的代码。因此，要写出优美代码，仍需要其他领域知识的支撑，数学只是一方面，谁知道哪一天会不会又有设计凡尔赛宫的需要呢？