---
layout: post
author: LPF
title: 计算机语言处理器
date: 2016-10-30 13:24:19
updated: 2017-02-21 16:18:59
tags:
- PL
categories:
- Study
- Computer
- PL
---
## 1 纯解释器

**纯解释器**直接工作于文本源文件，往往非常没有效率。

- 解释器持续扫描源文件(通常为ASCII文本文件)，将其当作字符串数据处理
- 为了识别**词素(lexeme)**——保留字、文字常量等语言组件，需要花费不少时间
- 所有语言转换器都要进行词法分析，而对词素实时分析执行最省力
- 纯解释器在期望语言处理程序非常紧凑的场合很受欢迎，且流行于脚本语言及超高级语言中，后者允许在程序执行期间将源代码当做字符串操作

## 2 解释器

**解释器**在程序运行时执行源文件的替身。这一替身并非人可阅读的文本文件。这种文件采用了特殊的**记号(token)**方式，使用专门的单字节**记号值**来表示源程序中的保留字等语句元素。

- 解释器对记号化的源文件操作，省去执行时分析词素的步骤
- 有的解释器读入文本源文件后，转换成记号化形式再执行之
- 记号化格式程序相对纯解释器执行速度要快，代价就是记号化源文件需要时间，并且可能无法将字符串当做程序语句执行

## 3 编译器

**编译器**将文本形式的源程序转换为可执行的机器码。

- 编译器生成的机器指令可由底层的CPU直接执行，从而无需解析源文件而浪费时间，因此执行速度要比解释性版本要快很多
- 编译器将源代码转换为机器码是单向的功能，而很难从给定的机器码重构得到程序原来的源文件

## 4 增量编译器

**增量编译器**是编译器和解释器的交集。

- 增量编译器类似于解释器，不会将源文件编译成机器码，而是将源代码转换到某种中间形式。
- 它又不像解释器，中间形式与原始源文件的联系并不紧密，这种中间形式通常是一种**虚拟机器语言**的机器码，没有哪个真正的CPU能执行这种代码。
- 然而，却很容易对这种虚拟机编写解释器，由后者来实际执行代码
- 由于虚拟机解释器往往比记号化代码要有效率得多，执行虚拟机器代码远比执行解释器中一大堆记号快
- 并且，虚拟机执行的一大优势在于虚拟机代码可移植——只要有解释器的地方就可执行虚拟机程序，而真正的机器代码只能在为之编写的CPU家族上执行。
- 一般来说，解释的虚拟机代码比解释性代码运行快2到10倍，而纯机器代码又比解释的虚拟机代码快2到10倍

**Java**等语言正是采用这种编译技术。



### 4.1 即时编译

其实在运行使其，解释器的相当多时间都花在了获得并解析虚拟机代码的操作上。程序执行时解释过程会反复进行。
**即时编译**会在首次遇到虚拟机指令时，就将虚拟机代码转换为实际机器码。当下一次遇到程序的同一语句时，则可以省掉解释过程。
