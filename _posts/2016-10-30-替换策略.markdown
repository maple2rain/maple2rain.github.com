---
layout: post
author: LPF
title: 替换策略
date: 2016-10-30 15:53:43
updated: 2017-02-21 16:17:28
tags:
- Process
categories:
- Study
- Computer
- OS
- Memory
---
## 1 概念

- 当主存中的所有帧都被占据，并且需要读取一个新页以满足一次页错误时，替换策略决定当前在主存中的哪个页将被替换。
- 所有策略的目标都是移出最近最不可能访问的页。
- 由于局部性原理，最近的访问历史和最近将要访问的模式间有很大的相关性，因此，大多数策略都基于过去的行为来预测将来的行为。
- 替换策略设计得越精致、越复杂，实现它的软硬件开销就越大。

## 2 帧锁定

在分析各种算法前，需要注意的是关于替换策略的一个约束：**主存中的某些帧可能是被锁定的。**

如果一个帧被锁定，当前保存在该帧中的页就不能被替换。
大部分操作系统内核和重要的控制结构就保存在锁定的帧中，此外，I/O缓冲区和其他对时间要求严格的区域也可能锁定在主存的帧中。

**锁定**是通过给每个帧关联一个*lock*位实现的，这一位可以包含在帧表和当前的页表中。

## 3 基本算法

### 3.1 最佳(optimal, OPT)

**OPT**策略选择替换下次访问距当前时间最长的页，但他要求操作系统必须知道将来的事件，而这是不可能实现的，不过其能作为一种标准来衡量其他算法的性能。

### 3.2 最近最少使用(Least Recently Used, LRU)

**LRU**策略替换主存中上次距当前最远的页。根据局部性原理，这也是最近最不可能访问到的页。
实际上，**LRU**策略的性能接近于**OPT**策略，但该方法的难于实现。

- 一种实现方法是给每一页添加一个最后一次访问的时间标签，并且必须在每次访问存储器时，不论访问的是指令或数据，都更新这个标签，这会导致非常大的开销
- 另一种方法是维护一个关于访问页的栈，但同样开销很大

### 3.3 先进先出(First In First Out, FIFO)

**FIFO**策略把分配给进程的页帧看做是一个循环缓冲区，按循环方式移动页。
这种选择方法所隐含的逻辑是替换驻留在主存中时间最长的页：一个很久以前取入主存的页，到现在可能不会再用到了，但这个推理常常是错误的，因为经常会出现一部分程序或数据在整个程序的生命周期中使用率都很高的情况，如果使用该算法，则这些页可能会反复地需要换入换出。

### 3.4 时钟(clock)

最简单的时钟策略需要给每一帧关联一个附加位称为使用位。
当某一位首次装入主存中时，该帧的使用位置为1；当该页随后被访问到时（在访问产生页错误后），他的使用位也被置为1。

- 页替换算法
    - 用于替换的候选帧集合被看做是一个循环缓冲区，并且有一个指针与之相关联
    - 当一页被替换时，该指针被设置成指向缓冲区的下一帧
    - 当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧
        - 每当遇到一个使用位为1的帧时，操作系统就将该位置为0
        - 如果在这个过程开始时，所有帧的使用位均为0，则选择遇到的第一个帧替换
        - 如果所有帧的使用位都为1，则指针在缓冲区完整地循环一周后把所有使用位置为0，并且停留在最初的位置上，替换该帧中的页
- 改良的页替换算法
    - 增加使用的位数目——修改位，从而，每一帧都处于以下四种情况之一
        - 最近未被访问，也未被修改（u = 0， m = 0）
        - 最近被访问，但未被修改（u = 1， m = 0）
        - 最近未被访问，但被修改（u = 0， m = 1）
        - 最近被访问，被修改（u = 1， m = 1）
    - 根据这个分类，时钟算法的执行如下
        - 从指针的当前位置开始，扫描帧缓冲区，在扫描过程中，对使用位不做修改，选择遇到的第一个帧(u = 0, m = 0)用于替换
        - 如果第1步失败，则重新扫描，查找（u = 0， m = 1）的帧，选择遇到的第一个这样的帧用于替换，并在扫描的过程中，对每个扫描过后的帧，将其使用位置为0
        - 如果第2步失败，指针将回到他的最初位置，并且集合中所有的使用位均为0。重复第1步，并且，如果有必要，重复第2步


在改良后的算法中，查找自从被取入到现在从未被修改过且最近没有访问过的页，这样的页最适合被替换，并且还有一个优点，他不需要被写回辅存。
如果在第一次扫描过程中没有找到候选页，则算法再次在缓冲区中开始循环，查找最近未被访问过的页，即使替换这样的页必须被写回，但由于局部性原理，他不会很快又需要用到。
该算法由于简单时钟算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样会节省时间。

## 4 进程挂起策略

- 最低优先级进程：实现调度策略决策，与性能问题无关
- 页错误进程：原因肯恩格式页错误任务的工作集还没有驻留，因而挂起他对性能的影响最小。此外，由于他阻塞了一个一定要被阻塞的进程，并且消除了页替换和I/O操作的开销，因而该选择可以立即收到成效
- 最后一个被激活的进程：这个进程的工作集最有可能还没有驻留
- 驻留集最小的进程：在将来再装入时所需要的代价最小。但是，它不利于局部性较小的程序
- 最大空间的进程：可以在一个过量使用的内存中得到最多的空闲帧，使得不会很快又处于去活状态(deactivation)
- 具有最大剩余执行窗口的进程：在大多数进程调度方案中，一个进程在被中断或者放置在就绪队列末尾之前只运行一定量的时间，这近似于最短处理时间优先的调度原则