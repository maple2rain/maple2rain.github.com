---
layout: post
author: LPF
title: 引用
date: 2016-12-06 22:26:17
updated: 2017-02-22 20:31:30
tags:
- C++
categories:
- Study
- Computer
- PL
- C++
---
# 1 引用规则

- 当引用被创建时，他必须被初始化
- 一旦一个引用被初始化为指向一个对象，他就不能改变成为另一个对象的引用
- 不能有NULL引用，必须确保引用是和一块合法的存储单元关联

# 2 函数中的引用

## 2.1 普通引用

- 当引用被用作函数参数时，在函数内任何对引用的更改将对函数外的参数产生改变
- 如果从函数中返回一个引用，则引用关联必须存在，否则将不知道指向哪一个内存，范例如下：

```c++
int& f(int &x){
    x++;
    return x; //Safe, x is outside this scope
}

int& g(){
    int q;
//!    return q; //Error, q is lost outside this scope

    static int x;
    return x; //Safe, x lives outside this scope
}
```

## 2.2 常量引用

- 对于内建类型，函数不会改变该参数
- 对于用户定义的类型，该函数只能调用常量成员函数，而且不应当改变任何公共的数据成员

### 2.2.1 使用常量引用很重要

在函数参数中使用常量引用特别重要。
有时函数会接收临时对象，其可能是由另一个函数的返回值创立；或由函数使用者显式创立。但临时对象总是不变的，因而如果不使用常量引用，参数将不会被编译器所接受。范例如下：

```c++
void f(int&) {}
void g(const int&){}

int main(){
//! f(1); //Error
    g(1); //Success
}
```

调用`f(1)`将会产生编译期间错误，这是因为编译器必须首先建立一个引用，即编译器为一个`int`类型分派存储单元，同时将其初始化为`1`并为其产生一个地址和引用捆绑在一起。而存储的内容必须是常量，因为改变他没有任何意义。

# 3 指针引用

在C语言中，如果想改变指针本身而不是他所指向的内容，则函数声明可能为：

```c++
void f(int **);
```

当传递他时，则必须显示的取得指针的地址：

```c++
int i;
int *ip = &i;
f(&ip);
```

对于C++，则将函数参数变成指针的引用，无需取指针地址，如：

```c++
void foo(int *&);

int i;
int *ip = &i;
foo(ip); //change ip rather than i
```

