---
layout: post
author: LPF
title: 面向对象结构的实现
date: 2016-10-30 13:27:32
updated: 2017-02-21 15:00:35
categories:
- Study
- Computer
- PL
- C++
---

## 1 存储实例数据

在C++中，将类定义为是对于C中的记录结构(**struct**)的一些扩展，即将记录结构作为类实例变量的存储结构，称其为类实例记录(**class instance record, CIR**)。
**CIR**的结构是静态的，因此它在编译时被建造，并且被用来作为产生类实例的模板。每个类都有它自己的**CIR**。
当派生类时，子类的**CIR**是父类的拷贝，新的实例变量项添加到末尾。
由于**CIR**的结构是静态的，所以可以使用从**CIR**实例开端的常量偏移来对所有实例变量进行访问。

## 2 消息对方法的动态绑定

静态绑定的类中的方法无须在类的**CIR**中涉及，编译器在编译过程中自动完成绑定。
动态绑定的方法必须在**CIR**结构中具有入口，这种入口可以仅仅是指向方法代码的一个指针，必须将他设立于创建对象之时。对于方法的调用就可以通过这个指针连接到相对应的代码上。缺点就是每一个实例都需要存储指向可能从这个实例调用的所有动态方法的指针。

### 2.1 虚拟方法表格

由于从类中的一个实例来调用的动态绑定办法对于这个类的所有实例都是相同的，因此，只需要将这些方法的表存储一次，而**CIR**只需要一个指针来指向这个表就能找到被调用的方法，这个表被称为**虚拟方法表格(virtual method table, vtable)**。

## 3 单继承时的CIR

静态绑定时，不论子类有没有对父类的方法进行覆盖，方法绑定都是在编译过程中实现的。类实例记录将记录父类的成员及自身的成员。

动态绑定时，子类将会在其**vtable**中存放父类的所有虚表信息，如果有覆盖或重写，则在表中将其方法代码替换，若有自定义的动态绑定方法，则将其添加到表的末尾。类实例记录将记录父类及自身的成员、虚表指针。
![](../post_img/58158fabab644162e1004284)


## 4 多继承时的CIR

静态绑定与单继承时一致。

动态绑定时，子类的**CIR**将保存多个父类的影像，每个影像存放一个父类的信息。此时，子类将会有多个**vtable**指针，其中一个存放子类与某个父类的影像，其他的存储剩余的父类的影像。如果子类有覆盖或重写，则在各个相关的表中将其方法代码替换，而子类自定义的动态绑定方法将保存在起初其和某个父类共同存在的**vtable**中。
**CIR**的最后是存放子类自身定义的成员。
![](../post_img/58158fabab644162e1004285)
